// Copyright 2020 The Serverless Workflow Specification Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package sw

import "fmt"
import "encoding/json"
import "reflect"

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventstateType, v)
	}
	*j = EventstateType(v)
	return nil
}

// Add additional extension context attributes to the produced event
type EventrefContextAttributes map[string]interface{}

// Event References
type Eventref struct {
	// Add additional extension context attributes to the produced event
	ContextAttributes EventrefContextAttributes `json:"contextAttributes,omitempty"`

	// If String, expression which selects parts of the states data output to become
	// the data of the produced event. If object a custom object to become the data of
	// produced event.
	Data interface{} `json:"data,omitempty"`

	// Reference to the unique name of a 'consumed' event definition
	ResultEventRef string `json:"resultEventRef"`

	// Reference to the unique name of a 'produced' event definition
	TriggerEventRef string `json:"triggerEventRef"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventref) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["resultEventRef"]; !ok || v == nil {
		return fmt.Errorf("field resultEventRef: required")
	}
	if v, ok := raw["triggerEventRef"]; !ok || v == nil {
		return fmt.Errorf("field triggerEventRef: required")
	}
	type Plain Eventref
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Eventref(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Function) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["resource"]; !ok || v == nil {
		return fmt.Errorf("field resource: required")
	}
	type Plain Function
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Function(plain)
	return nil
}

// Workflow CloudEvent definitions. Defines CloudEvents that can be consumed or
// produced
type Events []Eventdef

// UnmarshalJSON implements json.Unmarshaler.
func (j *Functionref) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["refName"]; !ok || v == nil {
		return fmt.Errorf("field refName: required")
	}
	type Plain Functionref
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Functionref(plain)
	return nil
}

type Action struct {
	// ActionDataFilter corresponds to the JSON schema field "actionDataFilter".
	ActionDataFilter *Actiondatafilter `json:"actionDataFilter,omitempty"`

	// References a 'trigger' and 'result' reusable event definitions
	EventRef *Eventref `json:"eventRef,omitempty"`

	// References a reusable function definition
	FunctionRef *Functionref `json:"functionRef,omitempty"`

	// Unique action definition name
	Name *string `json:"name,omitempty"`

	// Time period to wait for function execution to complete
	Timeout *string `json:"timeout,omitempty"`
}

// Branch Definition
type Branch struct {
	// Actions to be executed in this branch
	Actions []Action `json:"actions,omitempty"`

	// Branch name
	Name *string `json:"name,omitempty"`

	// States to be executed in this branch
	States []interface{} `json:"states,omitempty"`
}

type EndKind string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventdef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Eventdef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		plain.Kind = "consumed"
	}
	*j = Eventdef(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EndKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EndKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EndKind, v)
	}
	*j = EndKind(v)
	return nil
}

const EndKindDefault EndKind = "default"
const EndKindTerminate EndKind = "terminate"
const EndKindEvent EndKind = "event"

type Eventdef struct {
	// CloudEvent correlation definitions
	Correlation []CorrelationDef `json:"correlation,omitempty"`

	// Defines the CloudEvent as either 'consumed' or 'produced' by the workflow.
	// Default is 'consumed'
	Kind EventdefKind `json:"kind,omitempty"`

	// Metadata information
	Metadata Metadata `json:"metadata,omitempty"`

	// Unique event name
	Name *string `json:"name,omitempty"`

	// CloudEvent source
	Source *string `json:"source,omitempty"`

	// CloudEvent type
	Type *string `json:"type,omitempty"`
}

const EventdefKindProduced EventdefKind = "produced"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Produceevent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventRef"]; !ok || v == nil {
		return fmt.Errorf("field eventRef: required")
	}
	type Plain Produceevent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Produceevent(plain)
	return nil
}

// State end definition
type End struct {
	// Kind of end definition
	Kind *EndKind `json:"kind,omitempty"`

	// If end kind is event, select one of the defined 'produced' events by name and
	// set its data
	ProduceEvent *Produceevent `json:"produceEvent,omitempty"`
}

type Actiondatafilter struct {
	// JSONPath definition that selects parts of the states data input to be the
	// action data
	DataInputPath *string `json:"dataInputPath,omitempty"`

	// JSONPath definition that selects parts of the actions data result, to be merged
	// with the states data
	DataResultsPath *string `json:"dataResultsPath,omitempty"`
}

const EventdefKindConsumed EventdefKind = "consumed"

// Serverless Workflow is a vendor-neutral specification for defining the model of
// workflows responsible for orchestrating event-driven serverless applications
type Common map[string]interface{}

type Errordatafilter struct {
	// JSONPath definition that selects parts of the error data, to be merged with the
	// states data
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventdefKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventdefKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventdefKind, v)
	}
	*j = EventdefKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Transition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nextState"]; !ok || v == nil {
		return fmt.Errorf("field nextState: required")
	}
	type Plain Transition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Transition(plain)
	return nil
}

type Error struct {
	// ErrorDataFilter corresponds to the JSON schema field "errorDataFilter".
	ErrorDataFilter *Errordatafilter `json:"errorDataFilter,omitempty"`

	// Common Expression Language (CEL) expression. Should be evaluated against error
	// data. Must evaluate to true.
	Expression string `json:"expression"`

	// Next transition of the workflow when expression is matched
	Transition Transition `json:"transition"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Error) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["expression"]; !ok || v == nil {
		return fmt.Errorf("field expression: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	type Plain Error
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Error(plain)
	return nil
}

type EventdefKind string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Retry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["expression"]; !ok || v == nil {
		return fmt.Errorf("field expression: required")
	}
	type Plain Retry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["maxAttempts"]; !ok || v == nil {
		plain.MaxAttempts = 1
	}
	*j = Retry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CorrelationDef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contextAttributeName"]; !ok || v == nil {
		return fmt.Errorf("field contextAttributeName: required")
	}
	type Plain CorrelationDef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CorrelationDef(plain)
	return nil
}

// CloudEvent correlation definition
type CorrelationDef struct {
	// CloudEvent Extension Context Attribute name
	ContextAttributeName string `json:"contextAttributeName"`

	// CloudEvent Extension Context Attribute value
	ContextAttributeValue *string `json:"contextAttributeValue,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StartKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StartKind, v)
	}
	*j = StartKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Subflowstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Subflowstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["waitForCompletion"]; !ok || v == nil {
		plain.WaitForCompletion = false
	}
	*j = Subflowstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubflowstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubflowstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubflowstateType, v)
	}
	*j = SubflowstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Parallelstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Parallelstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["completionType"]; !ok || v == nil {
		plain.CompletionType = "and"
	}
	if v, ok := raw["n"]; !ok || v == nil {
		plain.N = 0
	}
	*j = Parallelstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParallelstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ParallelstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ParallelstateType, v)
	}
	*j = ParallelstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ScheduleDirectInvoke) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ScheduleDirectInvoke {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ScheduleDirectInvoke, v)
	}
	*j = ScheduleDirectInvoke(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParallelstateCompletionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ParallelstateCompletionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ParallelstateCompletionType, v)
	}
	*j = ParallelstateCompletionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Operationstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Operationstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["actionMode"]; !ok || v == nil {
		plain.ActionMode = "sequential"
	}
	*j = Operationstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OperationstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OperationstateType, v)
	}
	*j = OperationstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationstateActionMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OperationstateActionMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OperationstateActionMode, v)
	}
	*j = OperationstateActionMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InjectstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InjectstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InjectstateType, v)
	}
	*j = InjectstateType(v)
	return nil
}

type CallbackstateType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Foreachstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Foreachstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["max"]; !ok || v == nil {
		plain.Max = 0
	}
	*j = Foreachstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CallbackstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CallbackstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CallbackstateType, v)
	}
	*j = CallbackstateType(v)
	return nil
}

const CallbackstateTypeCallback CallbackstateType = "callback"

// This state performs an action, then waits for the callback event that denotes
// completion of the action
type Callbackstate struct {
	// Defines the action to be executed
	Action *Action `json:"action,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Callback event data filter definition
	EventDataFilter *Eventdatafilter `json:"eventDataFilter,omitempty"`

	// References an unique callback event name in the defined workflow events
	EventRef *string `json:"eventRef,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// States retry definitions
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// State data filter definition
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Time period to wait for incoming events (ISO 8601 format)
	Timeout *string `json:"timeout,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *CallbackstateType `json:"type,omitempty"`
}

type DataconditionOperator string

// Execute a set of defined states for each element of the data input array
type Foreachstate struct {
	// Actions to be executed for each of the elements of inputCollection
	Actions []Action `json:"actions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// JSONPath expression selecting a JSON array element of the states data input
	InputCollection *string `json:"inputCollection,omitempty"`

	// JSONPath expression specifying a JSON object field of the states data input.
	// For each parallel iteration, this field will get populated with a unique
	// element of the inputCollection array
	InputParameter *string `json:"inputParameter,omitempty"`

	// Specifies how upper bound on how many iterations may run in parallel
	Max int `json:"max,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// JSONPath expression specifying where in the states data output to place the
	// final data output of each iteration of the executed states
	OutputCollection *string `json:"outputCollection,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// States to be executed for each of the elements of inputCollection
	States []interface{} `json:"states,omitempty"`

	// Amount of time (ISO 8601 format) to wait between each iteration
	TimeDelay *string `json:"timeDelay,omitempty"`

	// Next transition of the workflow after state has completed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *ForeachstateType `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataconditionOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DataconditionOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DataconditionOperator, v)
	}
	*j = DataconditionOperator(v)
	return nil
}

const DataconditionOperatorExists DataconditionOperator = "exists"
const DataconditionOperatorNotexists DataconditionOperator = "notexists"
const DataconditionOperatorNull DataconditionOperator = "null"
const DataconditionOperatorNotnull DataconditionOperator = "notnull"
const DataconditionOperatorEquals DataconditionOperator = "equals"
const DataconditionOperatorNotequals DataconditionOperator = "notequals"
const DataconditionOperatorLessthan DataconditionOperator = "lessthan"
const DataconditionOperatorLessthanorequals DataconditionOperator = "lessthanorequals"
const DataconditionOperatorGreaterthan DataconditionOperator = "greaterthan"
const DataconditionOperatorGreaterthanorequals DataconditionOperator = "greaterthanorequals"
const DataconditionOperatorMatches DataconditionOperator = "matches"
const DataconditionOperatorNotmatches DataconditionOperator = "notmatches"
const DataconditionOperatorCustom DataconditionOperator = "custom"

// Switch state data based condition
type Datacondition struct {
	// Condition operator
	Operator DataconditionOperator `json:"operator"`

	// JSONPath expression that selects elements of state data
	Path string `json:"path"`

	// Next transition of the workflow if there is valid matches
	Transition Transition `json:"transition"`

	// Matching value
	Value string `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Datacondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["operator"]; !ok || v == nil {
		return fmt.Errorf("field operator: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain Datacondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Datacondition(plain)
	return nil
}

type DatabasedswitchType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForeachstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ForeachstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ForeachstateType, v)
	}
	*j = ForeachstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatabasedswitchType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DatabasedswitchType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DatabasedswitchType, v)
	}
	*j = DatabasedswitchType(v)
	return nil
}

const EventstateTypeEvent EventstateType = "event"

// Permits transitions to other states based on data conditions
type Databasedswitch struct {
	// Defines conditions evaluated against state data
	DataConditions []Datacondition `json:"dataConditions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Next transition of the workflow if there is no matching data conditions, or
	// event timeout is reached
	Default *Transition `json:"default,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// State type
	Type *DatabasedswitchType `json:"type,omitempty"`
}

type DelaystateType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Eventstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["exclusive"]; !ok || v == nil {
		plain.Exclusive = true
	}
	*j = Eventstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DelaystateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DelaystateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DelaystateType, v)
	}
	*j = DelaystateType(v)
	return nil
}

const DelaystateTypeDelay DelaystateType = "delay"

// Causes the workflow execution to delay for a specified duration
type Delaystate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// OnError Definition
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Amount of time (ISO 8601 format) to delay
	TimeDelay *string `json:"timeDelay,omitempty"`

	// Next transition of the workflow after the time delay
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *DelaystateType `json:"type,omitempty"`
}

type EventactionsActionMode string

type Eventdatafilter struct {
	// JSONPath definition that selects parts of the event data, to be merged with the
	// states data
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventactionsActionMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventactionsActionMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventactionsActionMode, v)
	}
	*j = EventactionsActionMode(v)
	return nil
}

const EventactionsActionModeSequential EventactionsActionMode = "sequential"
const DatabasedswitchTypeSwitch DatabasedswitchType = "switch"

type Eventactions struct {
	// Specifies how actions are to be performed (in sequence of parallel)
	ActionMode EventactionsActionMode `json:"actionMode,omitempty"`

	// Actions to be performed if expression matches
	Actions []Action `json:"actions"`

	// EventDataFilter corresponds to the JSON schema field "eventDataFilter".
	EventDataFilter *Eventdatafilter `json:"eventDataFilter,omitempty"`

	// References one or more unique event names in the defined workflow events
	EventRefs []string `json:"eventRefs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventactions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["actions"]; !ok || v == nil {
		return fmt.Errorf("field actions: required")
	}
	if v, ok := raw["eventRefs"]; !ok || v == nil {
		return fmt.Errorf("field eventRefs: required")
	}
	type Plain Eventactions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["actionMode"]; !ok || v == nil {
		plain.ActionMode = "sequential"
	}
	*j = Eventactions(plain)
	return nil
}

// Switch state data event condition
type Eventcondition struct {
	// References an unique event name in the defined workflow events
	EventRef string `json:"eventRef"`

	// Next transition of the workflow if there is valid matches
	Transition Transition `json:"transition"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventcondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventRef"]; !ok || v == nil {
		return fmt.Errorf("field eventRef: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	type Plain Eventcondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Eventcondition(plain)
	return nil
}

type EventbasedswitchType string

// This state is used to wait for events from event sources, then consumes them and
// invoke one or more actions to run in sequence or parallel
type Eventstate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Define what events trigger one or more actions to be performed
	EventsActions []Eventactions `json:"eventsActions,omitempty"`

	// If true consuming one of the defined events causes its associated actions to be
	// performed. If false all of the defined events must be consumed in order for
	// actions to be performed
	Exclusive bool `json:"exclusive,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Time period to wait for incoming events (ISO 8601 format)
	Timeout *string `json:"timeout,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *EventstateType `json:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventbasedswitchType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventbasedswitchType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventbasedswitchType, v)
	}
	*j = EventbasedswitchType(v)
	return nil
}

const EventbasedswitchTypeSwitch EventbasedswitchType = "switch"

// Permits transitions to other states based on events
type Eventbasedswitch struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Next transition of the workflow if there is no matching data conditions, or
	// event timeout is reached
	Default *Transition `json:"default,omitempty"`

	// Defines conditions evaluated against events
	EventConditions []Eventcondition `json:"eventConditions,omitempty"`

	// If eventConditions is used, defines the time period to wait for events (ISO
	// 8601 format)
	EventTimeout *string `json:"eventTimeout,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// State type
	Type *EventbasedswitchType `json:"type,omitempty"`
}

type EventstateType string

const EventactionsActionModeParallel EventactionsActionMode = "parallel"

type ForeachstateType string

const ForeachstateTypeForeach ForeachstateType = "foreach"

type Function struct {
	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// Unique function name
	Name string `json:"name"`

	// Function resource (URI)
	Resource string `json:"resource"`

	// Function type
	Type *string `json:"type,omitempty"`
}

// Function Reference
type Functionref struct {
	// Function parameters
	Parameters FunctionrefParameters `json:"parameters,omitempty"`

	// Name of the referenced function
	RefName string `json:"refName"`
}

// Function parameters
type FunctionrefParameters map[string]interface{}

// Workflow function definitions
type Functions []Function

// Inject static data into state data. Does not perform any actions
type Injectstate struct {
	// JSON object which can be set as states data input and can be manipulated via
	// filters
	Data InjectstateData `json:"data,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after subflow has completed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *InjectstateType `json:"type,omitempty"`
}

// JSON object which can be set as states data input and can be manipulated via
// filters
type InjectstateData map[string]interface{}

type InjectstateType string

const InjectstateTypeInject InjectstateType = "inject"

// Metadata information
type Metadata map[string]interface{}

// Defines actions be performed. Does not wait for incoming events
type Operationstate struct {
	// Specifies whether actions are performed in sequence or in parallel
	ActionMode OperationstateActionMode `json:"actionMode,omitempty"`

	// Actions to be performed
	Actions []Action `json:"actions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *OperationstateType `json:"type,omitempty"`
}

type OperationstateActionMode string

const OperationstateActionModeParallel OperationstateActionMode = "parallel"
const OperationstateActionModeSequential OperationstateActionMode = "sequential"

type OperationstateType string

const OperationstateTypeOperation OperationstateType = "operation"

// Consists of a number of states that are executed in parallel
type Parallelstate struct {
	// Branch Definitions
	Branches []Branch `json:"branches,omitempty"`

	// Option types on how to complete branch execution.
	CompletionType ParallelstateCompletionType `json:"completionType,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// Used when completionType is set to 'n_of_m' to specify the 'N' value
	N int `json:"n,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after all branches have completed execution
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *ParallelstateType `json:"type,omitempty"`
}

type ParallelstateCompletionType string

const ParallelstateCompletionTypeAnd ParallelstateCompletionType = "and"
const ParallelstateCompletionTypeNOfM ParallelstateCompletionType = "n_of_m"
const ParallelstateCompletionTypeXor ParallelstateCompletionType = "xor"

type ParallelstateType string

const ParallelstateTypeParallel ParallelstateType = "parallel"

// Produce an event and set its data
type Produceevent struct {
	// Add additional event extension context attributes
	ContextAttributes ProduceeventContextAttributes `json:"contextAttributes,omitempty"`

	// If String, expression which selects parts of the states data output to become
	// the data of the produced event. If object a custom object to become the data of
	// produced event.
	Data interface{} `json:"data,omitempty"`

	// References a name of a defined event
	EventRef string `json:"eventRef"`
}

// Add additional event extension context attributes
type ProduceeventContextAttributes map[string]interface{}

// Retry Definition
type Retry struct {
	// Common Expression Language (CEL) expression. Should be evaluated against state
	// data. Must evaluate to true for retry to execute.
	Expression string `json:"expression"`

	// Interval value for retry (ISO 8601 repeatable format)
	Interval *string `json:"interval,omitempty"`

	// Maximum number of retry attempts (1 by default). Value of 0 means no retries
	// are performed
	MaxAttempts int `json:"maxAttempts,omitempty"`

	// Multiplier value by which interval increases during each attempt (ISO 8601 time
	// format)
	Multiplier *string `json:"multiplier,omitempty"`
}

// Start state schedule definition
type Schedule struct {
	// Repeating interval (cron expression) describing when the workflow starting
	// state should be triggered
	Cron *string `json:"cron,omitempty"`

	// Define if workflow instances can be created outside of the defined
	// interval/cron
	DirectInvoke *ScheduleDirectInvoke `json:"directInvoke,omitempty"`

	// Time interval (ISO 8601 format) describing when the workflow starting state is
	// active
	Interval *string `json:"interval,omitempty"`

	// Timezone name used to evaluate the cron expression. Not used for interval as
	// timezone can be specified there directly. If not specified, should default to
	// local machine timezone.
	Timezone *string `json:"timezone,omitempty"`
}

type ScheduleDirectInvoke string

const ScheduleDirectInvokeAllow ScheduleDirectInvoke = "allow"
const ScheduleDirectInvokeDeny ScheduleDirectInvoke = "deny"

// State start definition
type Start struct {
	// Kind of start definition
	Kind *StartKind `json:"kind,omitempty"`

	// If kind is 'scheduled', define when the time/repeating intervals at which
	// workflow instances can/should be started
	Schedule *Schedule `json:"schedule,omitempty"`
}

type StartKind string

const StartKindDefault StartKind = "default"
const StartKindScheduled StartKind = "scheduled"

type Statedatafilter struct {
	// JSONPath definition that selects parts of the states data input
	DataInputPath *string `json:"dataInputPath,omitempty"`

	// JSONPath definition that selects parts of the states data output
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

// Defines a sub-workflow to be executed
type Subflowstate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after SubFlow has completed execution
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *SubflowstateType `json:"type,omitempty"`

	// Workflow execution must wait for sub-workflow to finish before continuing
	WaitForCompletion bool `json:"waitForCompletion,omitempty"`

	// Sub-workflow unique id
	WorkflowId *string `json:"workflowId,omitempty"`
}

type SubflowstateType string

const SubflowstateTypeSubflow SubflowstateType = "subflow"

type Switchstate interface{}

type Transition struct {
	// Common Expression Language (CEL) expression. Must evaluate to true for the
	// transition to be valid
	Expression *string `json:"expression,omitempty"`

	// Name of state to transition to
	NextState string `json:"nextState"`

	// Reference one of the defined 'produced' events by name and set its payload and
	// context attributes
	ProduceEvent *Produceevent `json:"produceEvent,omitempty"`
}

// Serverless Workflow is a vendor-neutral specification for defining the model of
// workflows responsible for orchestrating event-driven serverless applications
type Workflow struct {
	// URI to JSON Schema that workflow data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that workflow data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Workflow description
	Description *string `json:"description,omitempty"`

	// Events corresponds to the JSON schema field "events".
	Events Events `json:"events,omitempty"`

	// Workflow extensions
	Extensions []WorkflowExtensionsElem `json:"extensions,omitempty"`

	// Functions corresponds to the JSON schema field "functions".
	Functions Functions `json:"functions,omitempty"`

	// Workflow unique identifier
	Id string `json:"id"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// Workflow name
	Name string `json:"name"`

	// Serverless Workflow schema version
	SchemaVersion *string `json:"schemaVersion,omitempty"`

	// State definitions
	States []interface{} `json:"states"`

	// Workflow version
	Version string `json:"version"`
}

type WorkflowExtensionsElem map[string]interface{}

var enumValues_CallbackstateType = []interface{}{
	"callback",
}
var enumValues_DatabasedswitchType = []interface{}{
	"switch",
}
var enumValues_DataconditionOperator = []interface{}{
	"exists",
	"notexists",
	"null",
	"notnull",
	"equals",
	"notequals",
	"lessthan",
	"lessthanorequals",
	"greaterthan",
	"greaterthanorequals",
	"matches",
	"notmatches",
	"custom",
}
var enumValues_DelaystateType = []interface{}{
	"delay",
}
var enumValues_EndKind = []interface{}{
	"default",
	"terminate",
	"event",
}
var enumValues_EventactionsActionMode = []interface{}{
	"sequential",
	"parallel",
}
var enumValues_EventbasedswitchType = []interface{}{
	"switch",
}
var enumValues_EventdefKind = []interface{}{
	"consumed",
	"produced",
}
var enumValues_EventstateType = []interface{}{
	"event",
}
var enumValues_ForeachstateType = []interface{}{
	"foreach",
}
var enumValues_InjectstateType = []interface{}{
	"inject",
}
var enumValues_OperationstateActionMode = []interface{}{
	"sequential",
	"parallel",
}
var enumValues_OperationstateType = []interface{}{
	"operation",
}
var enumValues_ParallelstateCompletionType = []interface{}{
	"and",
	"xor",
	"n_of_m",
}
var enumValues_ParallelstateType = []interface{}{
	"parallel",
}
var enumValues_ScheduleDirectInvoke = []interface{}{
	"allow",
	"deny",
}
var enumValues_StartKind = []interface{}{
	"default",
	"scheduled",
}
var enumValues_SubflowstateType = []interface{}{
	"subflow",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Workflow) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["states"]; !ok || v == nil {
		return fmt.Errorf("field states: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version: required")
	}
	type Plain Workflow
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Workflow(plain)
	return nil
}
