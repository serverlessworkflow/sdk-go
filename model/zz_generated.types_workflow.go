// Copyright 2020 The Serverless Workflow Specification Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package model

import "fmt"
import "encoding/json"
import "reflect"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Enddeventcondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventRef"]; !ok || v == nil {
		return fmt.Errorf("field eventRef: required")
	}
	type Plain Enddeventcondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Enddeventcondition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParallelstateCompletionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ParallelstateCompletionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ParallelstateCompletionType, v)
	}
	*j = ParallelstateCompletionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Parallelstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Parallelstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["completionType"]; !ok || v == nil {
		plain.CompletionType = "and"
	}
	*j = Parallelstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventref) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["resultEventRef"]; !ok || v == nil {
		return fmt.Errorf("field resultEventRef: required")
	}
	if v, ok := raw["triggerEventRef"]; !ok || v == nil {
		return fmt.Errorf("field triggerEventRef: required")
	}
	type Plain Eventref
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Eventref(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Operationstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Operationstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["actionMode"]; !ok || v == nil {
		plain.ActionMode = "sequential"
	}
	*j = Operationstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationstateActionMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OperationstateActionMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OperationstateActionMode, v)
	}
	*j = OperationstateActionMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Functionref) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["refName"]; !ok || v == nil {
		return fmt.Errorf("field refName: required")
	}
	type Plain Functionref
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Functionref(plain)
	return nil
}

type Action struct {
	// ActionDataFilter corresponds to the JSON schema field "actionDataFilter".
	ActionDataFilter *Actiondatafilter `json:"actionDataFilter,omitempty"`

	// References a 'trigger' and 'result' reusable event definitions
	EventRef *Eventref `json:"eventRef,omitempty"`

	// References a reusable function definition
	FunctionRef *Functionref `json:"functionRef,omitempty"`

	// Unique action definition name
	Name *string `json:"name,omitempty"`

	// Time period to wait for function execution to complete
	Timeout *string `json:"timeout,omitempty"`
}

// Branch Definition
type Branch struct {
	// Actions to be executed in this branch
	Actions []Action `json:"actions,omitempty"`

	// Branch name
	Name *string `json:"name,omitempty"`

	// Unique Id of a workflow to be executed in this branch
	WorkflowId *string `json:"workflowId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ScheduleDirectInvoke) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ScheduleDirectInvoke {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ScheduleDirectInvoke, v)
	}
	*j = ScheduleDirectInvoke(v)
	return nil
}

type Actiondatafilter struct {
	// JsonPath definition that selects parts of the states data input to be the
	// action data
	DataInputPath *string `json:"dataInputPath,omitempty"`

	// JsonPath definition that selects parts of the actions data result, to be merged
	// with the states data
	DataResultsPath *string `json:"dataResultsPath,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EndKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EndKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EndKind, v)
	}
	*j = EndKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Enddatacondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["condition"]; !ok || v == nil {
		return fmt.Errorf("field condition: required")
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end: required")
	}
	type Plain Enddatacondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Enddatacondition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StartKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StartKind, v)
	}
	*j = StartKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Transitiondatacondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["condition"]; !ok || v == nil {
		return fmt.Errorf("field condition: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	type Plain Transitiondatacondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Transitiondatacondition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Eventstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["exclusive"]; !ok || v == nil {
		plain.Exclusive = true
	}
	*j = Eventstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Onevents) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["actions"]; !ok || v == nil {
		return fmt.Errorf("field actions: required")
	}
	if v, ok := raw["eventRefs"]; !ok || v == nil {
		return fmt.Errorf("field eventRefs: required")
	}
	type Plain Onevents
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["actionMode"]; !ok || v == nil {
		plain.ActionMode = "sequential"
	}
	*j = Onevents(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Produceeventdef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventRef"]; !ok || v == nil {
		return fmt.Errorf("field eventRef: required")
	}
	type Plain Produceeventdef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Produceeventdef(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OneventsActionMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OneventsActionMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OneventsActionMode, v)
	}
	*j = OneventsActionMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Subflowstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Subflowstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["waitForCompletion"]; !ok || v == nil {
		plain.WaitForCompletion = false
	}
	*j = Subflowstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Transitioneventcondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventRef"]; !ok || v == nil {
		return fmt.Errorf("field eventRef: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	type Plain Transitioneventcondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Transitioneventcondition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Transition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nextState"]; !ok || v == nil {
		return fmt.Errorf("field nextState: required")
	}
	type Plain Transition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Transition(plain)
	return nil
}

// This state performs an action, then waits for the callback event that denotes
// completion of the action
type Callbackstate struct {
	// Defines the action to be executed
	Action *Action `json:"action,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Callback event data filter definition
	EventDataFilter *Eventdatafilter `json:"eventDataFilter,omitempty"`

	// References an unique callback event name in the defined workflow events
	EventRef *string `json:"eventRef,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// State data filter definition
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Time period to wait for incoming events (ISO 8601 format)
	Timeout *string `json:"timeout,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

// Permits transitions to other states based on data conditions
type Databasedswitch struct {
	// Defines conditions evaluated against state data
	DataConditions []DatabasedswitchDataConditionsElem `json:"dataConditions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Default transition of the workflow if there is no matching data conditions. Can
	// include a transition or end definition
	Default *Defaultdef `json:"default,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

type DatabasedswitchDataConditionsElem interface{}

type Datacondition interface{}

// Default definition. Can be either a transition or end definition
type Defaultdef struct {
	// End corresponds to the JSON schema field "end".
	End *End `json:"end,omitempty"`

	// Transition corresponds to the JSON schema field "transition".
	Transition *Transition `json:"transition,omitempty"`
}

// Causes the workflow execution to delay for a specified duration
type Delaystate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Amount of time (ISO 8601 format) to delay
	TimeDelay *string `json:"timeDelay,omitempty"`

	// Next transition of the workflow after the time delay
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

// State end definition
type End struct {
	// Kind of end definition
	Kind *EndKind `json:"kind,omitempty"`

	// Used if kind is event. Array of events to be produced
	ProduceEvents []Produceeventdef `json:"produceEvents,omitempty"`
}

type EndKind string

const EndKindDefault EndKind = "default"
const EndKindEvent EndKind = "event"
const EndKindTerminate EndKind = "terminate"

// Switch state data based condition
type Enddatacondition struct {
	// JsonPath expression evaluated against state data. True if results are not empty
	Condition string `json:"condition"`

	// Explicit transition to end
	End End `json:"end"`

	// Data condition name
	Name *string `json:"name,omitempty"`
}

// Switch state data event condition
type Enddeventcondition struct {
	// Explicit transition to end
	End *End `json:"end,omitempty"`

	// References an unique event name in the defined workflow events
	EventRef string `json:"eventRef"`

	// Event condition name
	Name *string `json:"name,omitempty"`
}

type Error struct {
	// Error code. Can be used in addition to the name to help runtimes resolve to
	// technical errors/exceptions. Should not be defined if error is set to '*'
	Code *string `json:"code,omitempty"`

	// End workflow execution in case of this error. If retryRef is defined, this ends
	// workflow only if retries were unsuccessful.
	End *End `json:"end,omitempty"`

	// Domain-specific error name, or '*' to indicate all possible errors
	Error *string `json:"error,omitempty"`

	// References a unique name of a retry definition.
	RetryRef *string `json:"retryRef,omitempty"`

	// Transition to next state to handle the error. If retryRef is defined, this
	// transition is taken only if retries were unsuccessful.
	Transition *Transition `json:"transition,omitempty"`
}

type Errordatafilter struct {
	// JsonPath definition that selects parts of the error data, to be merged with the
	// states data
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

// Permits transitions to other states based on events
type Eventbasedswitch struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Default transition of the workflow if there is no matching data conditions. Can
	// include a transition or end definition
	Default *Defaultdef `json:"default,omitempty"`

	// Defines conditions evaluated against events
	EventConditions []EventbasedswitchEventConditionsElem `json:"eventConditions,omitempty"`

	// If eventConditions is used, defines the time period to wait for events (ISO
	// 8601 format)
	EventTimeout *string `json:"eventTimeout,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

type EventbasedswitchEventConditionsElem interface{}

type Eventcondition interface{}

type Eventdatafilter struct {
	// JsonPath definition that selects parts of the event data, to be merged with the
	// states data
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

// Event References
type Eventref struct {
	// Add additional extension context attributes to the produced event
	ContextAttributes EventrefContextAttributes `json:"contextAttributes,omitempty"`

	// If string type, an expression which selects parts of the states data output to
	// become the data (payload) of the event referenced by 'triggerEventRef'. If
	// object type, a custom object to become the data (payload) of the event
	// referenced by 'triggerEventRef'.
	Data interface{} `json:"data,omitempty"`

	// Reference to the unique name of a 'consumed' event definition
	ResultEventRef string `json:"resultEventRef"`

	// Reference to the unique name of a 'produced' event definition
	TriggerEventRef string `json:"triggerEventRef"`
}

// Add additional extension context attributes to the produced event
type EventrefContextAttributes map[string]interface{}

// This state is used to wait for events from event sources, then consumes them and
// invoke one or more actions to run in sequence or parallel
type Eventstate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// If true consuming one of the defined events causes its associated actions to be
	// performed. If false all of the defined events must be consumed in order for
	// actions to be performed
	Exclusive bool `json:"exclusive,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// Define what events trigger one or more actions to be performed
	OnEvents []Onevents `json:"onEvents,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Time period to wait for incoming events (ISO 8601 format)
	Timeout *string `json:"timeout,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

// Execute a set of defined actions or workflows for each element of a data array
type Foreachstate struct {
	// Actions to be executed for each of the elements of inputCollection
	Actions []Action `json:"actions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// JsonPath expression selecting an array element of the states data
	InputCollection *string `json:"inputCollection,omitempty"`

	// Name of the iteration parameter that can be referenced in actions/workflow. For
	// each parallel iteration, this param should contain an unique element of the
	// inputCollection array
	IterationParam *string `json:"iterationParam,omitempty"`

	// Specifies how upper bound on how many iterations may run in parallel
	Max interface{} `json:"max,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// JsonPath expression specifying an array element of the states data to add the
	// results of each iteration
	OutputCollection *string `json:"outputCollection,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after state has completed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`

	// Unique Id of a workflow to be executed for each of the elements of
	// inputCollection
	WorkflowId *string `json:"workflowId,omitempty"`
}

// Function Reference
type Functionref struct {
	// Function parameters
	Parameters FunctionrefParameters `json:"parameters,omitempty"`

	// Name of the referenced function
	RefName string `json:"refName"`
}

// Function parameters
type FunctionrefParameters map[string]interface{}

// Inject static data into state data. Does not perform any actions
type Injectstate struct {
	// JSON object which can be set as states data input and can be manipulated via
	// filters
	Data InjectstateData `json:"data,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after subflow has completed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

// JSON object which can be set as states data input and can be manipulated via
// filters
type InjectstateData map[string]interface{}

type Onevents struct {
	// Specifies how actions are to be performed (in sequence of parallel)
	ActionMode OneventsActionMode `json:"actionMode,omitempty"`

	// Actions to be performed if expression matches
	Actions []Action `json:"actions"`

	// EventDataFilter corresponds to the JSON schema field "eventDataFilter".
	EventDataFilter *Eventdatafilter `json:"eventDataFilter,omitempty"`

	// References one or more unique event names in the defined workflow events
	EventRefs []string `json:"eventRefs"`
}

type OneventsActionMode string

const OneventsActionModeParallel OneventsActionMode = "parallel"
const OneventsActionModeSequential OneventsActionMode = "sequential"

// Defines actions be performed. Does not wait for incoming events
type Operationstate struct {
	// Specifies whether actions are performed in sequence or in parallel
	ActionMode OperationstateActionMode `json:"actionMode,omitempty"`

	// Actions to be performed
	Actions []Action `json:"actions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

type OperationstateActionMode string

const OperationstateActionModeParallel OperationstateActionMode = "parallel"
const OperationstateActionModeSequential OperationstateActionMode = "sequential"

// Consists of a number of states that are executed in parallel
type Parallelstate struct {
	// Branch Definitions
	Branches []Branch `json:"branches,omitempty"`

	// Option types on how to complete branch execution.
	CompletionType ParallelstateCompletionType `json:"completionType,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// Used when completionType is set to 'n_of_m' to specify the 'N' value
	N interface{} `json:"n,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after all branches have completed execution
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`
}

type ParallelstateCompletionType string

const ParallelstateCompletionTypeAnd ParallelstateCompletionType = "and"
const ParallelstateCompletionTypeNOfM ParallelstateCompletionType = "n_of_m"
const ParallelstateCompletionTypeXor ParallelstateCompletionType = "xor"

// Produce an event and set its data
type Produceeventdef struct {
	// Add additional event extension context attributes
	ContextAttributes ProduceeventdefContextAttributes `json:"contextAttributes,omitempty"`

	// If String, expression which selects parts of the states data output to become
	// the data of the produced event. If object a custom object to become the data of
	// produced event.
	Data interface{} `json:"data,omitempty"`

	// References a name of a defined event
	EventRef string `json:"eventRef"`
}

// Add additional event extension context attributes
type ProduceeventdefContextAttributes map[string]interface{}

// Start state schedule definition
type Schedule struct {
	// Repeating interval (cron expression) describing when the workflow starting
	// state should be triggered
	Cron *string `json:"cron,omitempty"`

	// Define if workflow instances can be created outside of the defined
	// interval/cron
	DirectInvoke *ScheduleDirectInvoke `json:"directInvoke,omitempty"`

	// Time interval (ISO 8601 format) describing when the workflow starting state is
	// active
	Interval *string `json:"interval,omitempty"`

	// Timezone name used to evaluate the cron expression. Not used for interval as
	// timezone can be specified there directly. If not specified, should default to
	// local machine timezone.
	Timezone *string `json:"timezone,omitempty"`
}

type ScheduleDirectInvoke string

const ScheduleDirectInvokeAllow ScheduleDirectInvoke = "allow"
const ScheduleDirectInvokeDeny ScheduleDirectInvoke = "deny"

// State start definition
type Start struct {
	// Kind of start definition
	Kind *StartKind `json:"kind,omitempty"`

	// If kind is 'scheduled', define when the time/repeating intervals at which
	// workflow instances can/should be started
	Schedule *Schedule `json:"schedule,omitempty"`
}

type StartKind string

const StartKindDefault StartKind = "default"
const StartKindScheduled StartKind = "scheduled"

type Statedatafilter struct {
	// JsonPath definition that selects parts of the states data input
	DataInputPath *string `json:"dataInputPath,omitempty"`

	// JsonPath definition that selects parts of the states data output
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

// Defines a sub-workflow to be executed
type Subflowstate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata_1 `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling and retries definitions
	OnErrors []Error `json:"onErrors,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after SubFlow has completed execution
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *string `json:"type,omitempty"`

	// Workflow execution must wait for sub-workflow to finish before continuing
	WaitForCompletion bool `json:"waitForCompletion,omitempty"`

	// Sub-workflow unique id
	WorkflowId *string `json:"workflowId,omitempty"`
}

type Switchstate interface{}

type Transition struct {
	// JsonPath expression. Evaluates to true if returns non-empty result
	Expression *string `json:"expression,omitempty"`

	// Name of state to transition to
	NextState string `json:"nextState"`

	// Array of events to be produced
	ProduceEvents []Produceeventdef `json:"produceEvents,omitempty"`
}

// Switch state data based condition
type Transitiondatacondition struct {
	// JsonPath expression evaluated against state data. True if results are not empty
	Condition string `json:"condition"`

	// Data condition name
	Name *string `json:"name,omitempty"`

	// Next transition of the workflow if there is valid matches
	Transition Transition `json:"transition"`
}

// Switch state data event condition
type Transitioneventcondition struct {
	// References an unique event name in the defined workflow events
	EventRef string `json:"eventRef"`

	// Event condition name
	Name *string `json:"name,omitempty"`

	// Next transition of the workflow if there is valid matches
	Transition Transition `json:"transition"`
}

// Serverless Workflow specification - workflow schema

var enumValues_EndKind = []interface{}{
	"default",
	"terminate",
	"event",
}
var enumValues_OneventsActionMode = []interface{}{
	"sequential",
	"parallel",
}
var enumValues_OperationstateActionMode = []interface{}{
	"sequential",
	"parallel",
}
var enumValues_ParallelstateCompletionType = []interface{}{
	"and",
	"xor",
	"n_of_m",
}
var enumValues_ScheduleDirectInvoke = []interface{}{
	"allow",
	"deny",
}
var enumValues_StartKind = []interface{}{
	"default",
	"scheduled",
}
