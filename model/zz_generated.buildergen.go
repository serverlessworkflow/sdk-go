//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by main. DO NOT EDIT.

package model

import (
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewActionBuilder() *ActionBuilder {
	builder := &ActionBuilder{}
	builder.model = Action{}
	builder.model.ApplyDefault()
	builder.actiondatafilter = NewActionDataFilterBuilder()
	return builder
}

type ActionBuilder struct {
	model            Action
	functionref      *FunctionRefBuilder
	eventref         *EventRefBuilder
	subflowref       *WorkflowRefBuilder
	sleep            *SleepBuilder
	actiondatafilter *ActionDataFilterBuilder
}

func (b *ActionBuilder) ID(input string) *ActionBuilder {
	b.model.ID = input
	return b
}

func (b *ActionBuilder) Name(input string) *ActionBuilder {
	b.model.Name = input
	return b
}

func (b *ActionBuilder) FunctionRef() *FunctionRefBuilder {
	if b.functionref == nil {
		b.functionref = NewFunctionRefBuilder()
	}
	return b.functionref
}

func (b *ActionBuilder) EventRef() *EventRefBuilder {
	if b.eventref == nil {
		b.eventref = NewEventRefBuilder()
	}
	return b.eventref
}

func (b *ActionBuilder) SubFlowRef() *WorkflowRefBuilder {
	if b.subflowref == nil {
		b.subflowref = NewWorkflowRefBuilder()
	}
	return b.subflowref
}

func (b *ActionBuilder) Sleep() *SleepBuilder {
	if b.sleep == nil {
		b.sleep = NewSleepBuilder()
	}
	return b.sleep
}

func (b *ActionBuilder) RetryRef(input string) *ActionBuilder {
	b.model.RetryRef = input
	return b
}

func (b *ActionBuilder) NonRetryableErrors(input []string) *ActionBuilder {
	b.model.NonRetryableErrors = input
	return b
}

func (b *ActionBuilder) RetryableErrors(input []string) *ActionBuilder {
	b.model.RetryableErrors = input
	return b
}

func (b *ActionBuilder) ActionDataFilter() *ActionDataFilterBuilder {
	return b.actiondatafilter
}

func (b *ActionBuilder) Condition(input string) *ActionBuilder {
	b.model.Condition = input
	return b
}

func (b *ActionBuilder) Build() Action {
	if b.functionref != nil {
		functionref := b.functionref.Build()
		b.model.FunctionRef = &functionref
	}
	if b.eventref != nil {
		eventref := b.eventref.Build()
		b.model.EventRef = &eventref
	}
	if b.subflowref != nil {
		subflowref := b.subflowref.Build()
		b.model.SubFlowRef = &subflowref
	}
	if b.sleep != nil {
		sleep := b.sleep.Build()
		b.model.Sleep = &sleep
	}
	b.model.ActionDataFilter = b.actiondatafilter.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewActionDataFilterBuilder() *ActionDataFilterBuilder {
	builder := &ActionDataFilterBuilder{}
	builder.model = ActionDataFilter{}
	builder.model.ApplyDefault()
	return builder
}

type ActionDataFilterBuilder struct {
	model ActionDataFilter
}

func (b *ActionDataFilterBuilder) FromStateData(input string) *ActionDataFilterBuilder {
	b.model.FromStateData = input
	return b
}

func (b *ActionDataFilterBuilder) UseResults(input bool) *ActionDataFilterBuilder {
	b.model.UseResults = input
	return b
}

func (b *ActionDataFilterBuilder) Results(input string) *ActionDataFilterBuilder {
	b.model.Results = input
	return b
}

func (b *ActionDataFilterBuilder) ToStateData(input string) *ActionDataFilterBuilder {
	b.model.ToStateData = input
	return b
}

func (b *ActionDataFilterBuilder) Build() ActionDataFilter {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewAuthBuilder() *AuthBuilder {
	builder := &AuthBuilder{}
	builder.model = Auth{}
	builder.properties = NewAuthPropertiesBuilder()
	return builder
}

type AuthBuilder struct {
	model      Auth
	properties *AuthPropertiesBuilder
}

func (b *AuthBuilder) Name(input string) *AuthBuilder {
	b.model.Name = input
	return b
}

func (b *AuthBuilder) Scheme(input AuthType) *AuthBuilder {
	b.model.Scheme = input
	return b
}

func (b *AuthBuilder) Properties() *AuthPropertiesBuilder {
	return b.properties
}

func (b *AuthBuilder) Build() Auth {
	b.model.Properties = b.properties.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewAuthPropertiesBuilder() *AuthPropertiesBuilder {
	builder := &AuthPropertiesBuilder{}
	builder.model = AuthProperties{}
	return builder
}

type AuthPropertiesBuilder struct {
	model  AuthProperties
	basic  *BasicAuthPropertiesBuilder
	bearer *BearerAuthPropertiesBuilder
	oauth2 *OAuth2AuthPropertiesBuilder
}

func (b *AuthPropertiesBuilder) Basic() *BasicAuthPropertiesBuilder {
	if b.basic == nil {
		b.basic = NewBasicAuthPropertiesBuilder()
	}
	return b.basic
}

func (b *AuthPropertiesBuilder) Bearer() *BearerAuthPropertiesBuilder {
	if b.bearer == nil {
		b.bearer = NewBearerAuthPropertiesBuilder()
	}
	return b.bearer
}

func (b *AuthPropertiesBuilder) OAuth2() *OAuth2AuthPropertiesBuilder {
	if b.oauth2 == nil {
		b.oauth2 = NewOAuth2AuthPropertiesBuilder()
	}
	return b.oauth2
}

func (b *AuthPropertiesBuilder) Build() AuthProperties {
	if b.basic != nil {
		basic := b.basic.Build()
		b.model.Basic = &basic
	}
	if b.bearer != nil {
		bearer := b.bearer.Build()
		b.model.Bearer = &bearer
	}
	if b.oauth2 != nil {
		oauth2 := b.oauth2.Build()
		b.model.OAuth2 = &oauth2
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewAuthsBuilder() *AuthsBuilder {
	builder := &AuthsBuilder{}
	builder.model = Auths{}
	return builder
}

type AuthsBuilder struct {
	model Auths
}

func (b *AuthsBuilder) Build() Auths {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewBaseStateBuilder() *BaseStateBuilder {
	builder := &BaseStateBuilder{}
	builder.model = BaseState{}
	builder.onerrors = []*OnErrorBuilder{}
	return builder
}

type BaseStateBuilder struct {
	model           BaseState
	onerrors        []*OnErrorBuilder
	transition      *TransitionBuilder
	statedatafilter *StateDataFilterBuilder
	end             *EndBuilder
}

func (b *BaseStateBuilder) ID(input string) *BaseStateBuilder {
	b.model.ID = input
	return b
}

func (b *BaseStateBuilder) Name(input string) *BaseStateBuilder {
	b.model.Name = input
	return b
}

func (b *BaseStateBuilder) Type(input StateType) *BaseStateBuilder {
	b.model.Type = input
	return b
}

func (b *BaseStateBuilder) AddOnErrors() *OnErrorBuilder {
	builder := NewOnErrorBuilder()
	b.onerrors = append(b.onerrors, builder)
	return builder
}

func (b *BaseStateBuilder) RemoveOnErrors(remove *OnErrorBuilder) {
	for i, val := range b.onerrors {
		if val == remove {
			b.onerrors[i] = b.onerrors[len(b.onerrors)-1]
			b.onerrors = b.onerrors[:len(b.onerrors)-1]
		}
	}
}
func (b *BaseStateBuilder) Transition() *TransitionBuilder {
	if b.transition == nil {
		b.transition = NewTransitionBuilder()
	}
	return b.transition
}

func (b *BaseStateBuilder) StateDataFilter() *StateDataFilterBuilder {
	if b.statedatafilter == nil {
		b.statedatafilter = NewStateDataFilterBuilder()
	}
	return b.statedatafilter
}

func (b *BaseStateBuilder) CompensatedBy(input string) *BaseStateBuilder {
	b.model.CompensatedBy = input
	return b
}

func (b *BaseStateBuilder) UsedForCompensation(input bool) *BaseStateBuilder {
	b.model.UsedForCompensation = input
	return b
}

func (b *BaseStateBuilder) End() *EndBuilder {
	if b.end == nil {
		b.end = NewEndBuilder()
	}
	return b.end
}

func (b *BaseStateBuilder) Build() BaseState {
	b.model.OnErrors = []OnError{}
	for _, v := range b.onerrors {
		b.model.OnErrors = append(b.model.OnErrors, v.Build())
	}
	if b.transition != nil {
		transition := b.transition.Build()
		b.model.Transition = &transition
	}
	if b.statedatafilter != nil {
		statedatafilter := b.statedatafilter.Build()
		b.model.StateDataFilter = &statedatafilter
	}
	if b.end != nil {
		end := b.end.Build()
		b.model.End = &end
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewBaseWorkflowBuilder() *BaseWorkflowBuilder {
	builder := &BaseWorkflowBuilder{}
	builder.model = BaseWorkflow{}
	builder.model.ApplyDefault()
	builder.errors = []*ErrorBuilder{}
	builder.auth = []*AuthBuilder{}
	return builder
}

type BaseWorkflowBuilder struct {
	model           BaseWorkflow
	start           *StartBuilder
	datainputschema *DataInputSchemaBuilder
	constants       *ConstantsBuilder
	timeouts        *TimeoutsBuilder
	errors          []*ErrorBuilder
	auth            []*AuthBuilder
}

func (b *BaseWorkflowBuilder) ID(input string) *BaseWorkflowBuilder {
	b.model.ID = input
	return b
}

func (b *BaseWorkflowBuilder) Key(input string) *BaseWorkflowBuilder {
	b.model.Key = input
	return b
}

func (b *BaseWorkflowBuilder) Name(input string) *BaseWorkflowBuilder {
	b.model.Name = input
	return b
}

func (b *BaseWorkflowBuilder) Description(input string) *BaseWorkflowBuilder {
	b.model.Description = input
	return b
}

func (b *BaseWorkflowBuilder) Version(input string) *BaseWorkflowBuilder {
	b.model.Version = input
	return b
}

func (b *BaseWorkflowBuilder) Start() *StartBuilder {
	if b.start == nil {
		b.start = NewStartBuilder()
	}
	return b.start
}

func (b *BaseWorkflowBuilder) Annotations(input []string) *BaseWorkflowBuilder {
	b.model.Annotations = input
	return b
}

func (b *BaseWorkflowBuilder) DataInputSchema() *DataInputSchemaBuilder {
	if b.datainputschema == nil {
		b.datainputschema = NewDataInputSchemaBuilder()
	}
	return b.datainputschema
}

func (b *BaseWorkflowBuilder) SpecVersion(input string) *BaseWorkflowBuilder {
	b.model.SpecVersion = input
	return b
}

func (b *BaseWorkflowBuilder) Secrets(input Secrets) *BaseWorkflowBuilder {
	b.model.Secrets = input
	return b
}

func (b *BaseWorkflowBuilder) Constants() *ConstantsBuilder {
	if b.constants == nil {
		b.constants = NewConstantsBuilder()
	}
	return b.constants
}

func (b *BaseWorkflowBuilder) ExpressionLang(input ExpressionLangType) *BaseWorkflowBuilder {
	b.model.ExpressionLang = input
	return b
}

func (b *BaseWorkflowBuilder) Timeouts() *TimeoutsBuilder {
	if b.timeouts == nil {
		b.timeouts = NewTimeoutsBuilder()
	}
	return b.timeouts
}

func (b *BaseWorkflowBuilder) AddErrors() *ErrorBuilder {
	builder := NewErrorBuilder()
	b.errors = append(b.errors, builder)
	return builder
}

func (b *BaseWorkflowBuilder) RemoveErrors(remove *ErrorBuilder) {
	for i, val := range b.errors {
		if val == remove {
			b.errors[i] = b.errors[len(b.errors)-1]
			b.errors = b.errors[:len(b.errors)-1]
		}
	}
}
func (b *BaseWorkflowBuilder) KeepActive(input bool) *BaseWorkflowBuilder {
	b.model.KeepActive = input
	return b
}

func (b *BaseWorkflowBuilder) Metadata(input Metadata) *BaseWorkflowBuilder {
	b.model.Metadata = input
	return b
}

func (b *BaseWorkflowBuilder) AutoRetries(input bool) *BaseWorkflowBuilder {
	b.model.AutoRetries = input
	return b
}

func (b *BaseWorkflowBuilder) AddAuth() *AuthBuilder {
	builder := NewAuthBuilder()
	b.auth = append(b.auth, builder)
	return builder
}

func (b *BaseWorkflowBuilder) RemoveAuth(remove *AuthBuilder) {
	for i, val := range b.auth {
		if val == remove {
			b.auth[i] = b.auth[len(b.auth)-1]
			b.auth = b.auth[:len(b.auth)-1]
		}
	}
}
func (b *BaseWorkflowBuilder) Build() BaseWorkflow {
	if b.start != nil {
		start := b.start.Build()
		b.model.Start = &start
	}
	if b.datainputschema != nil {
		datainputschema := b.datainputschema.Build()
		b.model.DataInputSchema = &datainputschema
	}
	if b.constants != nil {
		constants := b.constants.Build()
		b.model.Constants = &constants
	}
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	b.model.Errors = []Error{}
	for _, v := range b.errors {
		b.model.Errors = append(b.model.Errors, v.Build())
	}
	b.model.Auth = []Auth{}
	for _, v := range b.auth {
		b.model.Auth = append(b.model.Auth, v.Build())
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewBasicAuthPropertiesBuilder() *BasicAuthPropertiesBuilder {
	builder := &BasicAuthPropertiesBuilder{}
	builder.model = BasicAuthProperties{}
	builder.CommonBuilder = *NewCommonBuilder()
	return builder
}

type BasicAuthPropertiesBuilder struct {
	model BasicAuthProperties
	CommonBuilder
}

func (b *BasicAuthPropertiesBuilder) Common() *CommonBuilder {
	return &b.CommonBuilder
}

func (b *BasicAuthPropertiesBuilder) Secret(input string) *BasicAuthPropertiesBuilder {
	b.model.Secret = input
	return b
}

func (b *BasicAuthPropertiesBuilder) Username(input string) *BasicAuthPropertiesBuilder {
	b.model.Username = input
	return b
}

func (b *BasicAuthPropertiesBuilder) Password(input string) *BasicAuthPropertiesBuilder {
	b.model.Password = input
	return b
}

func (b *BasicAuthPropertiesBuilder) Build() BasicAuthProperties {
	b.model.Common = b.CommonBuilder.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewBearerAuthPropertiesBuilder() *BearerAuthPropertiesBuilder {
	builder := &BearerAuthPropertiesBuilder{}
	builder.model = BearerAuthProperties{}
	builder.CommonBuilder = *NewCommonBuilder()
	return builder
}

type BearerAuthPropertiesBuilder struct {
	model BearerAuthProperties
	CommonBuilder
}

func (b *BearerAuthPropertiesBuilder) Common() *CommonBuilder {
	return &b.CommonBuilder
}

func (b *BearerAuthPropertiesBuilder) Secret(input string) *BearerAuthPropertiesBuilder {
	b.model.Secret = input
	return b
}

func (b *BearerAuthPropertiesBuilder) Token(input string) *BearerAuthPropertiesBuilder {
	b.model.Token = input
	return b
}

func (b *BearerAuthPropertiesBuilder) Build() BearerAuthProperties {
	b.model.Common = b.CommonBuilder.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewBranchBuilder() *BranchBuilder {
	builder := &BranchBuilder{}
	builder.model = Branch{}
	builder.actions = []*ActionBuilder{}
	return builder
}

type BranchBuilder struct {
	model    Branch
	actions  []*ActionBuilder
	timeouts *BranchTimeoutsBuilder
}

func (b *BranchBuilder) Name(input string) *BranchBuilder {
	b.model.Name = input
	return b
}

func (b *BranchBuilder) AddActions() *ActionBuilder {
	builder := NewActionBuilder()
	b.actions = append(b.actions, builder)
	return builder
}

func (b *BranchBuilder) RemoveActions(remove *ActionBuilder) {
	for i, val := range b.actions {
		if val == remove {
			b.actions[i] = b.actions[len(b.actions)-1]
			b.actions = b.actions[:len(b.actions)-1]
		}
	}
}
func (b *BranchBuilder) Timeouts() *BranchTimeoutsBuilder {
	if b.timeouts == nil {
		b.timeouts = NewBranchTimeoutsBuilder()
	}
	return b.timeouts
}

func (b *BranchBuilder) Build() Branch {
	b.model.Actions = []Action{}
	for _, v := range b.actions {
		b.model.Actions = append(b.model.Actions, v.Build())
	}
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewBranchTimeoutsBuilder() *BranchTimeoutsBuilder {
	builder := &BranchTimeoutsBuilder{}
	builder.model = BranchTimeouts{}
	return builder
}

type BranchTimeoutsBuilder struct {
	model BranchTimeouts
}

func (b *BranchTimeoutsBuilder) ActionExecTimeout(input string) *BranchTimeoutsBuilder {
	b.model.ActionExecTimeout = input
	return b
}

func (b *BranchTimeoutsBuilder) BranchExecTimeout(input string) *BranchTimeoutsBuilder {
	b.model.BranchExecTimeout = input
	return b
}

func (b *BranchTimeoutsBuilder) Build() BranchTimeouts {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewCallbackStateBuilder() *CallbackStateBuilder {
	builder := &CallbackStateBuilder{}
	builder.model = CallbackState{}
	builder.action = NewActionBuilder()
	return builder
}

type CallbackStateBuilder struct {
	model           CallbackState
	action          *ActionBuilder
	timeouts        *CallbackStateTimeoutBuilder
	eventdatafilter *EventDataFilterBuilder
}

func (b *CallbackStateBuilder) Action() *ActionBuilder {
	return b.action
}

func (b *CallbackStateBuilder) EventRef(input string) *CallbackStateBuilder {
	b.model.EventRef = input
	return b
}

func (b *CallbackStateBuilder) Timeouts() *CallbackStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewCallbackStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *CallbackStateBuilder) EventDataFilter() *EventDataFilterBuilder {
	if b.eventdatafilter == nil {
		b.eventdatafilter = NewEventDataFilterBuilder()
	}
	return b.eventdatafilter
}

func (b *CallbackStateBuilder) Build() CallbackState {
	b.model.Action = b.action.Build()
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	if b.eventdatafilter != nil {
		eventdatafilter := b.eventdatafilter.Build()
		b.model.EventDataFilter = &eventdatafilter
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewCallbackStateTimeoutBuilder() *CallbackStateTimeoutBuilder {
	builder := &CallbackStateTimeoutBuilder{}
	builder.model = CallbackStateTimeout{}
	return builder
}

type CallbackStateTimeoutBuilder struct {
	model            CallbackStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *CallbackStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *CallbackStateTimeoutBuilder) ActionExecTimeout(input string) *CallbackStateTimeoutBuilder {
	b.model.ActionExecTimeout = input
	return b
}

func (b *CallbackStateTimeoutBuilder) EventTimeout(input string) *CallbackStateTimeoutBuilder {
	b.model.EventTimeout = input
	return b
}

func (b *CallbackStateTimeoutBuilder) Build() CallbackStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewCommonBuilder() *CommonBuilder {
	builder := &CommonBuilder{}
	builder.model = Common{}
	return builder
}

type CommonBuilder struct {
	model Common
}

func (b *CommonBuilder) Metadata(input Metadata) *CommonBuilder {
	b.model.Metadata = input
	return b
}

func (b *CommonBuilder) Build() Common {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewConstantsBuilder() *ConstantsBuilder {
	builder := &ConstantsBuilder{}
	builder.model = Constants{}
	return builder
}

type ConstantsBuilder struct {
	model Constants
}

func (b *ConstantsBuilder) Data(input ConstantsData) *ConstantsBuilder {
	b.model.Data = input
	return b
}

func (b *ConstantsBuilder) Build() Constants {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewConstantsDataBuilder() *ConstantsDataBuilder {
	builder := &ConstantsDataBuilder{}
	builder.model = ConstantsData{}
	return builder
}

type ConstantsDataBuilder struct {
	model ConstantsData
}

func (b *ConstantsDataBuilder) Build() ConstantsData {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewContinueAsBuilder() *ContinueAsBuilder {
	builder := &ContinueAsBuilder{}
	builder.model = ContinueAs{}
	builder.data = NewObjectBuilder()
	builder.workflowexectimeout = NewWorkflowExecTimeoutBuilder()
	return builder
}

type ContinueAsBuilder struct {
	model               ContinueAs
	data                *ObjectBuilder
	workflowexectimeout *WorkflowExecTimeoutBuilder
}

func (b *ContinueAsBuilder) WorkflowID(input string) *ContinueAsBuilder {
	b.model.WorkflowID = input
	return b
}

func (b *ContinueAsBuilder) Version(input string) *ContinueAsBuilder {
	b.model.Version = input
	return b
}

func (b *ContinueAsBuilder) Data() *ObjectBuilder {
	return b.data
}

func (b *ContinueAsBuilder) WorkflowExecTimeout() *WorkflowExecTimeoutBuilder {
	return b.workflowexectimeout
}

func (b *ContinueAsBuilder) Build() ContinueAs {
	b.model.Data = b.data.Build()
	b.model.WorkflowExecTimeout = b.workflowexectimeout.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewCorrelationBuilder() *CorrelationBuilder {
	builder := &CorrelationBuilder{}
	builder.model = Correlation{}
	return builder
}

type CorrelationBuilder struct {
	model Correlation
}

func (b *CorrelationBuilder) ContextAttributeName(input string) *CorrelationBuilder {
	b.model.ContextAttributeName = input
	return b
}

func (b *CorrelationBuilder) ContextAttributeValue(input string) *CorrelationBuilder {
	b.model.ContextAttributeValue = input
	return b
}

func (b *CorrelationBuilder) Build() Correlation {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewCronBuilder() *CronBuilder {
	builder := &CronBuilder{}
	builder.model = Cron{}
	return builder
}

type CronBuilder struct {
	model Cron
}

func (b *CronBuilder) Expression(input string) *CronBuilder {
	b.model.Expression = input
	return b
}

func (b *CronBuilder) ValidUntil(input string) *CronBuilder {
	b.model.ValidUntil = input
	return b
}

func (b *CronBuilder) Build() Cron {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewDataConditionBuilder() *DataConditionBuilder {
	builder := &DataConditionBuilder{}
	builder.model = DataCondition{}
	return builder
}

type DataConditionBuilder struct {
	model      DataCondition
	end        *EndBuilder
	transition *TransitionBuilder
}

func (b *DataConditionBuilder) Name(input string) *DataConditionBuilder {
	b.model.Name = input
	return b
}

func (b *DataConditionBuilder) Condition(input string) *DataConditionBuilder {
	b.model.Condition = input
	return b
}

func (b *DataConditionBuilder) Metadata(input Metadata) *DataConditionBuilder {
	b.model.Metadata = input
	return b
}

func (b *DataConditionBuilder) End() *EndBuilder {
	if b.end == nil {
		b.end = NewEndBuilder()
	}
	return b.end
}

func (b *DataConditionBuilder) Transition() *TransitionBuilder {
	if b.transition == nil {
		b.transition = NewTransitionBuilder()
	}
	return b.transition
}

func (b *DataConditionBuilder) Build() DataCondition {
	if b.end != nil {
		end := b.end.Build()
		b.model.End = &end
	}
	if b.transition != nil {
		transition := b.transition.Build()
		b.model.Transition = &transition
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewDataInputSchemaBuilder() *DataInputSchemaBuilder {
	builder := &DataInputSchemaBuilder{}
	builder.model = DataInputSchema{}
	builder.model.ApplyDefault()
	return builder
}

type DataInputSchemaBuilder struct {
	model DataInputSchema
}

func (b *DataInputSchemaBuilder) Schema(input string) *DataInputSchemaBuilder {
	b.model.Schema = input
	return b
}

func (b *DataInputSchemaBuilder) FailOnValidationErrors(input bool) *DataInputSchemaBuilder {
	b.model.FailOnValidationErrors = input
	return b
}

func (b *DataInputSchemaBuilder) Build() DataInputSchema {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewDefaultConditionBuilder() *DefaultConditionBuilder {
	builder := &DefaultConditionBuilder{}
	builder.model = DefaultCondition{}
	return builder
}

type DefaultConditionBuilder struct {
	model      DefaultCondition
	transition *TransitionBuilder
	end        *EndBuilder
}

func (b *DefaultConditionBuilder) Transition() *TransitionBuilder {
	if b.transition == nil {
		b.transition = NewTransitionBuilder()
	}
	return b.transition
}

func (b *DefaultConditionBuilder) End() *EndBuilder {
	if b.end == nil {
		b.end = NewEndBuilder()
	}
	return b.end
}

func (b *DefaultConditionBuilder) Build() DefaultCondition {
	if b.transition != nil {
		transition := b.transition.Build()
		b.model.Transition = &transition
	}
	if b.end != nil {
		end := b.end.Build()
		b.model.End = &end
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewDelayStateBuilder() *DelayStateBuilder {
	builder := &DelayStateBuilder{}
	builder.model = DelayState{}
	return builder
}

type DelayStateBuilder struct {
	model DelayState
}

func (b *DelayStateBuilder) TimeDelay(input string) *DelayStateBuilder {
	b.model.TimeDelay = input
	return b
}

func (b *DelayStateBuilder) Build() DelayState {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEndBuilder() *EndBuilder {
	builder := &EndBuilder{}
	builder.model = End{}
	builder.produceevents = []*ProduceEventBuilder{}
	return builder
}

type EndBuilder struct {
	model         End
	produceevents []*ProduceEventBuilder
	continueas    *ContinueAsBuilder
}

func (b *EndBuilder) Terminate(input bool) *EndBuilder {
	b.model.Terminate = input
	return b
}

func (b *EndBuilder) AddProduceEvents() *ProduceEventBuilder {
	builder := NewProduceEventBuilder()
	b.produceevents = append(b.produceevents, builder)
	return builder
}

func (b *EndBuilder) RemoveProduceEvents(remove *ProduceEventBuilder) {
	for i, val := range b.produceevents {
		if val == remove {
			b.produceevents[i] = b.produceevents[len(b.produceevents)-1]
			b.produceevents = b.produceevents[:len(b.produceevents)-1]
		}
	}
}
func (b *EndBuilder) Compensate(input bool) *EndBuilder {
	b.model.Compensate = input
	return b
}

func (b *EndBuilder) ContinueAs() *ContinueAsBuilder {
	if b.continueas == nil {
		b.continueas = NewContinueAsBuilder()
	}
	return b.continueas
}

func (b *EndBuilder) Build() End {
	b.model.ProduceEvents = []ProduceEvent{}
	for _, v := range b.produceevents {
		b.model.ProduceEvents = append(b.model.ProduceEvents, v.Build())
	}
	if b.continueas != nil {
		continueas := b.continueas.Build()
		b.model.ContinueAs = &continueas
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewErrorBuilder() *ErrorBuilder {
	builder := &ErrorBuilder{}
	builder.model = Error{}
	return builder
}

type ErrorBuilder struct {
	model Error
}

func (b *ErrorBuilder) Name(input string) *ErrorBuilder {
	b.model.Name = input
	return b
}

func (b *ErrorBuilder) Code(input string) *ErrorBuilder {
	b.model.Code = input
	return b
}

func (b *ErrorBuilder) Description(input string) *ErrorBuilder {
	b.model.Description = input
	return b
}

func (b *ErrorBuilder) Build() Error {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewErrorsBuilder() *ErrorsBuilder {
	builder := &ErrorsBuilder{}
	builder.model = Errors{}
	return builder
}

type ErrorsBuilder struct {
	model Errors
}

func (b *ErrorsBuilder) Build() Errors {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventBuilder() *EventBuilder {
	builder := &EventBuilder{}
	builder.model = Event{}
	builder.model.ApplyDefault()
	builder.CommonBuilder = *NewCommonBuilder()
	builder.correlation = []*CorrelationBuilder{}
	return builder
}

type EventBuilder struct {
	model Event
	CommonBuilder
	correlation []*CorrelationBuilder
}

func (b *EventBuilder) Common() *CommonBuilder {
	return &b.CommonBuilder
}

func (b *EventBuilder) Name(input string) *EventBuilder {
	b.model.Name = input
	return b
}

func (b *EventBuilder) Source(input string) *EventBuilder {
	b.model.Source = input
	return b
}

func (b *EventBuilder) Type(input string) *EventBuilder {
	b.model.Type = input
	return b
}

func (b *EventBuilder) Kind(input EventKind) *EventBuilder {
	b.model.Kind = input
	return b
}

func (b *EventBuilder) DataOnly(input bool) *EventBuilder {
	b.model.DataOnly = input
	return b
}

func (b *EventBuilder) AddCorrelation() *CorrelationBuilder {
	builder := NewCorrelationBuilder()
	b.correlation = append(b.correlation, builder)
	return builder
}

func (b *EventBuilder) RemoveCorrelation(remove *CorrelationBuilder) {
	for i, val := range b.correlation {
		if val == remove {
			b.correlation[i] = b.correlation[len(b.correlation)-1]
			b.correlation = b.correlation[:len(b.correlation)-1]
		}
	}
}
func (b *EventBuilder) Build() Event {
	b.model.Common = b.CommonBuilder.Build()
	b.model.Correlation = []Correlation{}
	for _, v := range b.correlation {
		b.model.Correlation = append(b.model.Correlation, v.Build())
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventConditionBuilder() *EventConditionBuilder {
	builder := &EventConditionBuilder{}
	builder.model = EventCondition{}
	return builder
}

type EventConditionBuilder struct {
	model           EventCondition
	eventdatafilter *EventDataFilterBuilder
	end             *EndBuilder
	transition      *TransitionBuilder
}

func (b *EventConditionBuilder) Name(input string) *EventConditionBuilder {
	b.model.Name = input
	return b
}

func (b *EventConditionBuilder) EventRef(input string) *EventConditionBuilder {
	b.model.EventRef = input
	return b
}

func (b *EventConditionBuilder) EventDataFilter() *EventDataFilterBuilder {
	if b.eventdatafilter == nil {
		b.eventdatafilter = NewEventDataFilterBuilder()
	}
	return b.eventdatafilter
}

func (b *EventConditionBuilder) Metadata(input Metadata) *EventConditionBuilder {
	b.model.Metadata = input
	return b
}

func (b *EventConditionBuilder) End() *EndBuilder {
	if b.end == nil {
		b.end = NewEndBuilder()
	}
	return b.end
}

func (b *EventConditionBuilder) Transition() *TransitionBuilder {
	if b.transition == nil {
		b.transition = NewTransitionBuilder()
	}
	return b.transition
}

func (b *EventConditionBuilder) Build() EventCondition {
	if b.eventdatafilter != nil {
		eventdatafilter := b.eventdatafilter.Build()
		b.model.EventDataFilter = &eventdatafilter
	}
	if b.end != nil {
		end := b.end.Build()
		b.model.End = &end
	}
	if b.transition != nil {
		transition := b.transition.Build()
		b.model.Transition = &transition
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventConditionsBuilder() *EventConditionsBuilder {
	builder := &EventConditionsBuilder{}
	builder.model = EventConditions{}
	return builder
}

type EventConditionsBuilder struct {
	model EventConditions
}

func (b *EventConditionsBuilder) Build() EventConditions {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventDataFilterBuilder() *EventDataFilterBuilder {
	builder := &EventDataFilterBuilder{}
	builder.model = EventDataFilter{}
	builder.model.ApplyDefault()
	return builder
}

type EventDataFilterBuilder struct {
	model EventDataFilter
}

func (b *EventDataFilterBuilder) UseData(input bool) *EventDataFilterBuilder {
	b.model.UseData = input
	return b
}

func (b *EventDataFilterBuilder) Data(input string) *EventDataFilterBuilder {
	b.model.Data = input
	return b
}

func (b *EventDataFilterBuilder) ToStateData(input string) *EventDataFilterBuilder {
	b.model.ToStateData = input
	return b
}

func (b *EventDataFilterBuilder) Build() EventDataFilter {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventRefBuilder() *EventRefBuilder {
	builder := &EventRefBuilder{}
	builder.model = EventRef{}
	builder.model.ApplyDefault()
	return builder
}

type EventRefBuilder struct {
	model EventRef
	data  *ObjectBuilder
}

func (b *EventRefBuilder) TriggerEventRef(input string) *EventRefBuilder {
	b.model.TriggerEventRef = input
	return b
}

func (b *EventRefBuilder) ResultEventRef(input string) *EventRefBuilder {
	b.model.ResultEventRef = input
	return b
}

func (b *EventRefBuilder) ResultEventTimeout(input string) *EventRefBuilder {
	b.model.ResultEventTimeout = input
	return b
}

func (b *EventRefBuilder) Data() *ObjectBuilder {
	if b.data == nil {
		b.data = NewObjectBuilder()
	}
	return b.data
}

func (b *EventRefBuilder) ContextAttributes(input map[string]Object) *EventRefBuilder {
	b.model.ContextAttributes = input
	return b
}

func (b *EventRefBuilder) Invoke(input InvokeKind) *EventRefBuilder {
	b.model.Invoke = input
	return b
}

func (b *EventRefBuilder) Build() EventRef {
	if b.data != nil {
		data := b.data.Build()
		b.model.Data = &data
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventStateBuilder() *EventStateBuilder {
	builder := &EventStateBuilder{}
	builder.model = EventState{}
	builder.model.ApplyDefault()
	builder.onevents = []*OnEventsBuilder{}
	return builder
}

type EventStateBuilder struct {
	model    EventState
	onevents []*OnEventsBuilder
	timeouts *EventStateTimeoutBuilder
}

func (b *EventStateBuilder) Exclusive(input bool) *EventStateBuilder {
	b.model.Exclusive = input
	return b
}

func (b *EventStateBuilder) AddOnEvents() *OnEventsBuilder {
	builder := NewOnEventsBuilder()
	b.onevents = append(b.onevents, builder)
	return builder
}

func (b *EventStateBuilder) RemoveOnEvents(remove *OnEventsBuilder) {
	for i, val := range b.onevents {
		if val == remove {
			b.onevents[i] = b.onevents[len(b.onevents)-1]
			b.onevents = b.onevents[:len(b.onevents)-1]
		}
	}
}
func (b *EventStateBuilder) Timeouts() *EventStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewEventStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *EventStateBuilder) Build() EventState {
	b.model.OnEvents = []OnEvents{}
	for _, v := range b.onevents {
		b.model.OnEvents = append(b.model.OnEvents, v.Build())
	}
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventStateTimeoutBuilder() *EventStateTimeoutBuilder {
	builder := &EventStateTimeoutBuilder{}
	builder.model = EventStateTimeout{}
	return builder
}

type EventStateTimeoutBuilder struct {
	model            EventStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *EventStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *EventStateTimeoutBuilder) ActionExecTimeout(input string) *EventStateTimeoutBuilder {
	b.model.ActionExecTimeout = input
	return b
}

func (b *EventStateTimeoutBuilder) EventTimeout(input string) *EventStateTimeoutBuilder {
	b.model.EventTimeout = input
	return b
}

func (b *EventStateTimeoutBuilder) Build() EventStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewEventsBuilder() *EventsBuilder {
	builder := &EventsBuilder{}
	builder.model = Events{}
	return builder
}

type EventsBuilder struct {
	model Events
}

func (b *EventsBuilder) Build() Events {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewForEachStateBuilder() *ForEachStateBuilder {
	builder := &ForEachStateBuilder{}
	builder.model = ForEachState{}
	builder.model.ApplyDefault()
	builder.actions = []*ActionBuilder{}
	return builder
}

type ForEachStateBuilder struct {
	model    ForEachState
	actions  []*ActionBuilder
	timeouts *ForEachStateTimeoutBuilder
}

func (b *ForEachStateBuilder) InputCollection(input string) *ForEachStateBuilder {
	b.model.InputCollection = input
	return b
}

func (b *ForEachStateBuilder) OutputCollection(input string) *ForEachStateBuilder {
	b.model.OutputCollection = input
	return b
}

func (b *ForEachStateBuilder) IterationParam(input string) *ForEachStateBuilder {
	b.model.IterationParam = input
	return b
}

func (b *ForEachStateBuilder) BatchSize(input *intstr.IntOrString) *ForEachStateBuilder {
	b.model.BatchSize = input
	return b
}

func (b *ForEachStateBuilder) AddActions() *ActionBuilder {
	builder := NewActionBuilder()
	b.actions = append(b.actions, builder)
	return builder
}

func (b *ForEachStateBuilder) RemoveActions(remove *ActionBuilder) {
	for i, val := range b.actions {
		if val == remove {
			b.actions[i] = b.actions[len(b.actions)-1]
			b.actions = b.actions[:len(b.actions)-1]
		}
	}
}
func (b *ForEachStateBuilder) Timeouts() *ForEachStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewForEachStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *ForEachStateBuilder) Mode(input ForEachModeType) *ForEachStateBuilder {
	b.model.Mode = input
	return b
}

func (b *ForEachStateBuilder) Build() ForEachState {
	b.model.Actions = []Action{}
	for _, v := range b.actions {
		b.model.Actions = append(b.model.Actions, v.Build())
	}
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewForEachStateTimeoutBuilder() *ForEachStateTimeoutBuilder {
	builder := &ForEachStateTimeoutBuilder{}
	builder.model = ForEachStateTimeout{}
	return builder
}

type ForEachStateTimeoutBuilder struct {
	model            ForEachStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *ForEachStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *ForEachStateTimeoutBuilder) ActionExecTimeout(input string) *ForEachStateTimeoutBuilder {
	b.model.ActionExecTimeout = input
	return b
}

func (b *ForEachStateTimeoutBuilder) Build() ForEachStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewFunctionBuilder() *FunctionBuilder {
	builder := &FunctionBuilder{}
	builder.model = Function{}
	builder.model.ApplyDefault()
	builder.CommonBuilder = *NewCommonBuilder()
	return builder
}

type FunctionBuilder struct {
	model Function
	CommonBuilder
}

func (b *FunctionBuilder) Common() *CommonBuilder {
	return &b.CommonBuilder
}

func (b *FunctionBuilder) Name(input string) *FunctionBuilder {
	b.model.Name = input
	return b
}

func (b *FunctionBuilder) Operation(input string) *FunctionBuilder {
	b.model.Operation = input
	return b
}

func (b *FunctionBuilder) Type(input FunctionType) *FunctionBuilder {
	b.model.Type = input
	return b
}

func (b *FunctionBuilder) AuthRef(input string) *FunctionBuilder {
	b.model.AuthRef = input
	return b
}

func (b *FunctionBuilder) Build() Function {
	b.model.Common = b.CommonBuilder.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewFunctionRefBuilder() *FunctionRefBuilder {
	builder := &FunctionRefBuilder{}
	builder.model = FunctionRef{}
	builder.model.ApplyDefault()
	return builder
}

type FunctionRefBuilder struct {
	model FunctionRef
}

func (b *FunctionRefBuilder) RefName(input string) *FunctionRefBuilder {
	b.model.RefName = input
	return b
}

func (b *FunctionRefBuilder) Arguments(input map[string]Object) *FunctionRefBuilder {
	b.model.Arguments = input
	return b
}

func (b *FunctionRefBuilder) SelectionSet(input string) *FunctionRefBuilder {
	b.model.SelectionSet = input
	return b
}

func (b *FunctionRefBuilder) Invoke(input InvokeKind) *FunctionRefBuilder {
	b.model.Invoke = input
	return b
}

func (b *FunctionRefBuilder) Build() FunctionRef {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewFunctionsBuilder() *FunctionsBuilder {
	builder := &FunctionsBuilder{}
	builder.model = Functions{}
	return builder
}

type FunctionsBuilder struct {
	model Functions
}

func (b *FunctionsBuilder) Build() Functions {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewInjectStateBuilder() *InjectStateBuilder {
	builder := &InjectStateBuilder{}
	builder.model = InjectState{}
	return builder
}

type InjectStateBuilder struct {
	model    InjectState
	timeouts *InjectStateTimeoutBuilder
}

func (b *InjectStateBuilder) Data(input map[string]Object) *InjectStateBuilder {
	b.model.Data = input
	return b
}

func (b *InjectStateBuilder) Timeouts() *InjectStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewInjectStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *InjectStateBuilder) Build() InjectState {
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewInjectStateTimeoutBuilder() *InjectStateTimeoutBuilder {
	builder := &InjectStateTimeoutBuilder{}
	builder.model = InjectStateTimeout{}
	return builder
}

type InjectStateTimeoutBuilder struct {
	model            InjectStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *InjectStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *InjectStateTimeoutBuilder) Build() InjectStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewMetadataBuilder() *MetadataBuilder {
	builder := &MetadataBuilder{}
	builder.model = Metadata{}
	return builder
}

type MetadataBuilder struct {
	model Metadata
}

func (b *MetadataBuilder) Build() Metadata {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewOAuth2AuthPropertiesBuilder() *OAuth2AuthPropertiesBuilder {
	builder := &OAuth2AuthPropertiesBuilder{}
	builder.model = OAuth2AuthProperties{}
	builder.CommonBuilder = *NewCommonBuilder()
	return builder
}

type OAuth2AuthPropertiesBuilder struct {
	model OAuth2AuthProperties
	CommonBuilder
}

func (b *OAuth2AuthPropertiesBuilder) Common() *CommonBuilder {
	return &b.CommonBuilder
}

func (b *OAuth2AuthPropertiesBuilder) Secret(input string) *OAuth2AuthPropertiesBuilder {
	b.model.Secret = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) Authority(input string) *OAuth2AuthPropertiesBuilder {
	b.model.Authority = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) GrantType(input GrantType) *OAuth2AuthPropertiesBuilder {
	b.model.GrantType = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) ClientID(input string) *OAuth2AuthPropertiesBuilder {
	b.model.ClientID = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) ClientSecret(input string) *OAuth2AuthPropertiesBuilder {
	b.model.ClientSecret = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) Scopes(input []string) *OAuth2AuthPropertiesBuilder {
	b.model.Scopes = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) Username(input string) *OAuth2AuthPropertiesBuilder {
	b.model.Username = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) Password(input string) *OAuth2AuthPropertiesBuilder {
	b.model.Password = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) Audiences(input []string) *OAuth2AuthPropertiesBuilder {
	b.model.Audiences = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) SubjectToken(input string) *OAuth2AuthPropertiesBuilder {
	b.model.SubjectToken = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) RequestedSubject(input string) *OAuth2AuthPropertiesBuilder {
	b.model.RequestedSubject = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) RequestedIssuer(input string) *OAuth2AuthPropertiesBuilder {
	b.model.RequestedIssuer = input
	return b
}

func (b *OAuth2AuthPropertiesBuilder) Build() OAuth2AuthProperties {
	b.model.Common = b.CommonBuilder.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewObjectBuilder() *ObjectBuilder {
	builder := &ObjectBuilder{}
	builder.model = Object{}
	builder.slicevalue = []*ObjectBuilder{}
	return builder
}

type ObjectBuilder struct {
	model      Object
	slicevalue []*ObjectBuilder
}

func (b *ObjectBuilder) Type(input Type) *ObjectBuilder {
	b.model.Type = input
	return b
}

func (b *ObjectBuilder) StringValue(input string) *ObjectBuilder {
	b.model.StringValue = input
	return b
}

func (b *ObjectBuilder) IntValue(input int32) *ObjectBuilder {
	b.model.IntValue = input
	return b
}

func (b *ObjectBuilder) FloatValue(input float64) *ObjectBuilder {
	b.model.FloatValue = input
	return b
}

func (b *ObjectBuilder) MapValue(input map[string]Object) *ObjectBuilder {
	b.model.MapValue = input
	return b
}

func (b *ObjectBuilder) AddSliceValue() *ObjectBuilder {
	builder := NewObjectBuilder()
	b.slicevalue = append(b.slicevalue, builder)
	return builder
}

func (b *ObjectBuilder) RemoveSliceValue(remove *ObjectBuilder) {
	for i, val := range b.slicevalue {
		if val == remove {
			b.slicevalue[i] = b.slicevalue[len(b.slicevalue)-1]
			b.slicevalue = b.slicevalue[:len(b.slicevalue)-1]
		}
	}
}
func (b *ObjectBuilder) BoolValue(input bool) *ObjectBuilder {
	b.model.BoolValue = input
	return b
}

func (b *ObjectBuilder) Build() Object {
	b.model.SliceValue = []Object{}
	for _, v := range b.slicevalue {
		b.model.SliceValue = append(b.model.SliceValue, v.Build())
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewOnErrorBuilder() *OnErrorBuilder {
	builder := &OnErrorBuilder{}
	builder.model = OnError{}
	return builder
}

type OnErrorBuilder struct {
	model      OnError
	transition *TransitionBuilder
	end        *EndBuilder
}

func (b *OnErrorBuilder) ErrorRef(input string) *OnErrorBuilder {
	b.model.ErrorRef = input
	return b
}

func (b *OnErrorBuilder) ErrorRefs(input []string) *OnErrorBuilder {
	b.model.ErrorRefs = input
	return b
}

func (b *OnErrorBuilder) Transition() *TransitionBuilder {
	if b.transition == nil {
		b.transition = NewTransitionBuilder()
	}
	return b.transition
}

func (b *OnErrorBuilder) End() *EndBuilder {
	if b.end == nil {
		b.end = NewEndBuilder()
	}
	return b.end
}

func (b *OnErrorBuilder) Build() OnError {
	if b.transition != nil {
		transition := b.transition.Build()
		b.model.Transition = &transition
	}
	if b.end != nil {
		end := b.end.Build()
		b.model.End = &end
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewOnEventsBuilder() *OnEventsBuilder {
	builder := &OnEventsBuilder{}
	builder.model = OnEvents{}
	builder.model.ApplyDefault()
	builder.actions = []*ActionBuilder{}
	builder.eventdatafilter = NewEventDataFilterBuilder()
	return builder
}

type OnEventsBuilder struct {
	model           OnEvents
	actions         []*ActionBuilder
	eventdatafilter *EventDataFilterBuilder
}

func (b *OnEventsBuilder) EventRefs(input []string) *OnEventsBuilder {
	b.model.EventRefs = input
	return b
}

func (b *OnEventsBuilder) ActionMode(input ActionMode) *OnEventsBuilder {
	b.model.ActionMode = input
	return b
}

func (b *OnEventsBuilder) AddActions() *ActionBuilder {
	builder := NewActionBuilder()
	b.actions = append(b.actions, builder)
	return builder
}

func (b *OnEventsBuilder) RemoveActions(remove *ActionBuilder) {
	for i, val := range b.actions {
		if val == remove {
			b.actions[i] = b.actions[len(b.actions)-1]
			b.actions = b.actions[:len(b.actions)-1]
		}
	}
}
func (b *OnEventsBuilder) EventDataFilter() *EventDataFilterBuilder {
	return b.eventdatafilter
}

func (b *OnEventsBuilder) Build() OnEvents {
	b.model.Actions = []Action{}
	for _, v := range b.actions {
		b.model.Actions = append(b.model.Actions, v.Build())
	}
	b.model.EventDataFilter = b.eventdatafilter.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewOperationStateBuilder() *OperationStateBuilder {
	builder := &OperationStateBuilder{}
	builder.model = OperationState{}
	builder.model.ApplyDefault()
	builder.actions = []*ActionBuilder{}
	return builder
}

type OperationStateBuilder struct {
	model    OperationState
	actions  []*ActionBuilder
	timeouts *OperationStateTimeoutBuilder
}

func (b *OperationStateBuilder) ActionMode(input ActionMode) *OperationStateBuilder {
	b.model.ActionMode = input
	return b
}

func (b *OperationStateBuilder) AddActions() *ActionBuilder {
	builder := NewActionBuilder()
	b.actions = append(b.actions, builder)
	return builder
}

func (b *OperationStateBuilder) RemoveActions(remove *ActionBuilder) {
	for i, val := range b.actions {
		if val == remove {
			b.actions[i] = b.actions[len(b.actions)-1]
			b.actions = b.actions[:len(b.actions)-1]
		}
	}
}
func (b *OperationStateBuilder) Timeouts() *OperationStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewOperationStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *OperationStateBuilder) Build() OperationState {
	b.model.Actions = []Action{}
	for _, v := range b.actions {
		b.model.Actions = append(b.model.Actions, v.Build())
	}
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewOperationStateTimeoutBuilder() *OperationStateTimeoutBuilder {
	builder := &OperationStateTimeoutBuilder{}
	builder.model = OperationStateTimeout{}
	return builder
}

type OperationStateTimeoutBuilder struct {
	model            OperationStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *OperationStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *OperationStateTimeoutBuilder) ActionExecTimeout(input string) *OperationStateTimeoutBuilder {
	b.model.ActionExecTimeout = input
	return b
}

func (b *OperationStateTimeoutBuilder) Build() OperationStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewParallelStateBuilder() *ParallelStateBuilder {
	builder := &ParallelStateBuilder{}
	builder.model = ParallelState{}
	builder.model.ApplyDefault()
	builder.branches = []*BranchBuilder{}
	return builder
}

type ParallelStateBuilder struct {
	model    ParallelState
	branches []*BranchBuilder
	timeouts *ParallelStateTimeoutBuilder
}

func (b *ParallelStateBuilder) AddBranches() *BranchBuilder {
	builder := NewBranchBuilder()
	b.branches = append(b.branches, builder)
	return builder
}

func (b *ParallelStateBuilder) RemoveBranches(remove *BranchBuilder) {
	for i, val := range b.branches {
		if val == remove {
			b.branches[i] = b.branches[len(b.branches)-1]
			b.branches = b.branches[:len(b.branches)-1]
		}
	}
}
func (b *ParallelStateBuilder) CompletionType(input CompletionType) *ParallelStateBuilder {
	b.model.CompletionType = input
	return b
}

func (b *ParallelStateBuilder) NumCompleted(input intstr.IntOrString) *ParallelStateBuilder {
	b.model.NumCompleted = input
	return b
}

func (b *ParallelStateBuilder) Timeouts() *ParallelStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewParallelStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *ParallelStateBuilder) Build() ParallelState {
	b.model.Branches = []Branch{}
	for _, v := range b.branches {
		b.model.Branches = append(b.model.Branches, v.Build())
	}
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewParallelStateTimeoutBuilder() *ParallelStateTimeoutBuilder {
	builder := &ParallelStateTimeoutBuilder{}
	builder.model = ParallelStateTimeout{}
	return builder
}

type ParallelStateTimeoutBuilder struct {
	model            ParallelStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *ParallelStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *ParallelStateTimeoutBuilder) BranchExecTimeout(input string) *ParallelStateTimeoutBuilder {
	b.model.BranchExecTimeout = input
	return b
}

func (b *ParallelStateTimeoutBuilder) Build() ParallelStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewProduceEventBuilder() *ProduceEventBuilder {
	builder := &ProduceEventBuilder{}
	builder.model = ProduceEvent{}
	builder.data = NewObjectBuilder()
	return builder
}

type ProduceEventBuilder struct {
	model ProduceEvent
	data  *ObjectBuilder
}

func (b *ProduceEventBuilder) EventRef(input string) *ProduceEventBuilder {
	b.model.EventRef = input
	return b
}

func (b *ProduceEventBuilder) Data() *ObjectBuilder {
	return b.data
}

func (b *ProduceEventBuilder) ContextAttributes(input map[string]string) *ProduceEventBuilder {
	b.model.ContextAttributes = input
	return b
}

func (b *ProduceEventBuilder) Build() ProduceEvent {
	b.model.Data = b.data.Build()
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewRetriesBuilder() *RetriesBuilder {
	builder := &RetriesBuilder{}
	builder.model = Retries{}
	return builder
}

type RetriesBuilder struct {
	model Retries
}

func (b *RetriesBuilder) Build() Retries {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewRetryBuilder() *RetryBuilder {
	builder := &RetryBuilder{}
	builder.model = Retry{}
	builder.model.ApplyDefault()
	return builder
}

type RetryBuilder struct {
	model Retry
}

func (b *RetryBuilder) Name(input string) *RetryBuilder {
	b.model.Name = input
	return b
}

func (b *RetryBuilder) Delay(input string) *RetryBuilder {
	b.model.Delay = input
	return b
}

func (b *RetryBuilder) MaxDelay(input string) *RetryBuilder {
	b.model.MaxDelay = input
	return b
}

func (b *RetryBuilder) Increment(input string) *RetryBuilder {
	b.model.Increment = input
	return b
}

func (b *RetryBuilder) MaxAttempts(input intstr.IntOrString) *RetryBuilder {
	b.model.MaxAttempts = input
	return b
}

func (b *RetryBuilder) Build() Retry {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewScheduleBuilder() *ScheduleBuilder {
	builder := &ScheduleBuilder{}
	builder.model = Schedule{}
	return builder
}

type ScheduleBuilder struct {
	model Schedule
	cron  *CronBuilder
}

func (b *ScheduleBuilder) Interval(input string) *ScheduleBuilder {
	b.model.Interval = input
	return b
}

func (b *ScheduleBuilder) Cron() *CronBuilder {
	if b.cron == nil {
		b.cron = NewCronBuilder()
	}
	return b.cron
}

func (b *ScheduleBuilder) Timezone(input string) *ScheduleBuilder {
	b.model.Timezone = input
	return b
}

func (b *ScheduleBuilder) Build() Schedule {
	if b.cron != nil {
		cron := b.cron.Build()
		b.model.Cron = &cron
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewSecretsBuilder() *SecretsBuilder {
	builder := &SecretsBuilder{}
	builder.model = Secrets{}
	return builder
}

type SecretsBuilder struct {
	model Secrets
}

func (b *SecretsBuilder) Build() Secrets {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewSleepBuilder() *SleepBuilder {
	builder := &SleepBuilder{}
	builder.model = Sleep{}
	return builder
}

type SleepBuilder struct {
	model Sleep
}

func (b *SleepBuilder) Before(input string) *SleepBuilder {
	b.model.Before = input
	return b
}

func (b *SleepBuilder) After(input string) *SleepBuilder {
	b.model.After = input
	return b
}

func (b *SleepBuilder) Build() Sleep {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewSleepStateBuilder() *SleepStateBuilder {
	builder := &SleepStateBuilder{}
	builder.model = SleepState{}
	return builder
}

type SleepStateBuilder struct {
	model    SleepState
	timeouts *SleepStateTimeoutBuilder
}

func (b *SleepStateBuilder) Duration(input string) *SleepStateBuilder {
	b.model.Duration = input
	return b
}

func (b *SleepStateBuilder) Timeouts() *SleepStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewSleepStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *SleepStateBuilder) Build() SleepState {
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewSleepStateTimeoutBuilder() *SleepStateTimeoutBuilder {
	builder := &SleepStateTimeoutBuilder{}
	builder.model = SleepStateTimeout{}
	return builder
}

type SleepStateTimeoutBuilder struct {
	model            SleepStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *SleepStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *SleepStateTimeoutBuilder) Build() SleepStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewStartBuilder() *StartBuilder {
	builder := &StartBuilder{}
	builder.model = Start{}
	return builder
}

type StartBuilder struct {
	model    Start
	schedule *ScheduleBuilder
}

func (b *StartBuilder) StateName(input string) *StartBuilder {
	b.model.StateName = input
	return b
}

func (b *StartBuilder) Schedule() *ScheduleBuilder {
	if b.schedule == nil {
		b.schedule = NewScheduleBuilder()
	}
	return b.schedule
}

func (b *StartBuilder) Build() Start {
	if b.schedule != nil {
		schedule := b.schedule.Build()
		b.model.Schedule = &schedule
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewStateBuilder() *StateBuilder {
	builder := &StateBuilder{}
	builder.model = State{}
	builder.BaseStateBuilder = *NewBaseStateBuilder()
	return builder
}

type StateBuilder struct {
	model State
	BaseStateBuilder
	*DelayStateBuilder
	*EventStateBuilder
	*OperationStateBuilder
	*ParallelStateBuilder
	*SwitchStateBuilder
	*ForEachStateBuilder
	*InjectStateBuilder
	*CallbackStateBuilder
	*SleepStateBuilder
}

func (b *StateBuilder) ID(input string) *StateBuilder {
	b.BaseStateBuilder.ID(input)
	return b
}

func (b *StateBuilder) Name(input string) *StateBuilder {
	b.BaseStateBuilder.Name(input)
	return b
}

func (b *StateBuilder) Type(input StateType) *StateBuilder {
	b.BaseStateBuilder.Type(input)
	return b
}

func (b *StateBuilder) CompensatedBy(input string) *StateBuilder {
	b.BaseStateBuilder.CompensatedBy(input)
	return b
}

func (b *StateBuilder) UsedForCompensation(input bool) *StateBuilder {
	b.BaseStateBuilder.UsedForCompensation(input)
	return b
}

func (b *StateBuilder) DelayState() *DelayStateBuilder {
	if b.DelayStateBuilder == nil {
		b.DelayStateBuilder = NewDelayStateBuilder()
	}
	return b.DelayStateBuilder
}

func (b *StateBuilder) TimeDelay(input string) *StateBuilder {
	b.DelayStateBuilder.TimeDelay(input)
	return b
}

func (b *StateBuilder) EventState() *EventStateBuilder {
	if b.EventStateBuilder == nil {
		b.EventStateBuilder = NewEventStateBuilder()
	}
	return b.EventStateBuilder
}

func (b *StateBuilder) Exclusive(input bool) *StateBuilder {
	b.EventStateBuilder.Exclusive(input)
	return b
}

func (b *StateBuilder) OperationState() *OperationStateBuilder {
	if b.OperationStateBuilder == nil {
		b.OperationStateBuilder = NewOperationStateBuilder()
	}
	return b.OperationStateBuilder
}

func (b *StateBuilder) ActionMode(input ActionMode) *StateBuilder {
	b.OperationStateBuilder.ActionMode(input)
	return b
}

func (b *StateBuilder) ParallelState() *ParallelStateBuilder {
	if b.ParallelStateBuilder == nil {
		b.ParallelStateBuilder = NewParallelStateBuilder()
	}
	return b.ParallelStateBuilder
}

func (b *StateBuilder) CompletionType(input CompletionType) *StateBuilder {
	b.ParallelStateBuilder.CompletionType(input)
	return b
}

func (b *StateBuilder) SwitchState() *SwitchStateBuilder {
	if b.SwitchStateBuilder == nil {
		b.SwitchStateBuilder = NewSwitchStateBuilder()
	}
	return b.SwitchStateBuilder
}

func (b *StateBuilder) ForEachState() *ForEachStateBuilder {
	if b.ForEachStateBuilder == nil {
		b.ForEachStateBuilder = NewForEachStateBuilder()
	}
	return b.ForEachStateBuilder
}

func (b *StateBuilder) InputCollection(input string) *StateBuilder {
	b.ForEachStateBuilder.InputCollection(input)
	return b
}

func (b *StateBuilder) OutputCollection(input string) *StateBuilder {
	b.ForEachStateBuilder.OutputCollection(input)
	return b
}

func (b *StateBuilder) IterationParam(input string) *StateBuilder {
	b.ForEachStateBuilder.IterationParam(input)
	return b
}

func (b *StateBuilder) Mode(input ForEachModeType) *StateBuilder {
	b.ForEachStateBuilder.Mode(input)
	return b
}

func (b *StateBuilder) InjectState() *InjectStateBuilder {
	if b.InjectStateBuilder == nil {
		b.InjectStateBuilder = NewInjectStateBuilder()
	}
	return b.InjectStateBuilder
}

func (b *StateBuilder) CallbackState() *CallbackStateBuilder {
	if b.CallbackStateBuilder == nil {
		b.CallbackStateBuilder = NewCallbackStateBuilder()
	}
	return b.CallbackStateBuilder
}

func (b *StateBuilder) EventRef(input string) *StateBuilder {
	b.CallbackStateBuilder.EventRef(input)
	return b
}

func (b *StateBuilder) SleepState() *SleepStateBuilder {
	if b.SleepStateBuilder == nil {
		b.SleepStateBuilder = NewSleepStateBuilder()
	}
	return b.SleepStateBuilder
}

func (b *StateBuilder) Duration(input string) *StateBuilder {
	b.SleepStateBuilder.Duration(input)
	return b
}

func (b *StateBuilder) Build() State {
	b.model.BaseState = b.BaseStateBuilder.Build()
	if b.DelayStateBuilder != nil {
		delaystate := b.DelayStateBuilder.Build()
		b.model.DelayState = &delaystate
	}
	if b.EventStateBuilder != nil {
		eventstate := b.EventStateBuilder.Build()
		b.model.EventState = &eventstate
	}
	if b.OperationStateBuilder != nil {
		operationstate := b.OperationStateBuilder.Build()
		b.model.OperationState = &operationstate
	}
	if b.ParallelStateBuilder != nil {
		parallelstate := b.ParallelStateBuilder.Build()
		b.model.ParallelState = &parallelstate
	}
	if b.SwitchStateBuilder != nil {
		switchstate := b.SwitchStateBuilder.Build()
		b.model.SwitchState = &switchstate
	}
	if b.ForEachStateBuilder != nil {
		foreachstate := b.ForEachStateBuilder.Build()
		b.model.ForEachState = &foreachstate
	}
	if b.InjectStateBuilder != nil {
		injectstate := b.InjectStateBuilder.Build()
		b.model.InjectState = &injectstate
	}
	if b.CallbackStateBuilder != nil {
		callbackstate := b.CallbackStateBuilder.Build()
		b.model.CallbackState = &callbackstate
	}
	if b.SleepStateBuilder != nil {
		sleepstate := b.SleepStateBuilder.Build()
		b.model.SleepState = &sleepstate
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewStateDataFilterBuilder() *StateDataFilterBuilder {
	builder := &StateDataFilterBuilder{}
	builder.model = StateDataFilter{}
	return builder
}

type StateDataFilterBuilder struct {
	model StateDataFilter
}

func (b *StateDataFilterBuilder) Input(input string) *StateDataFilterBuilder {
	b.model.Input = input
	return b
}

func (b *StateDataFilterBuilder) Output(input string) *StateDataFilterBuilder {
	b.model.Output = input
	return b
}

func (b *StateDataFilterBuilder) Build() StateDataFilter {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewStateExecTimeoutBuilder() *StateExecTimeoutBuilder {
	builder := &StateExecTimeoutBuilder{}
	builder.model = StateExecTimeout{}
	return builder
}

type StateExecTimeoutBuilder struct {
	model StateExecTimeout
}

func (b *StateExecTimeoutBuilder) Single(input string) *StateExecTimeoutBuilder {
	b.model.Single = input
	return b
}

func (b *StateExecTimeoutBuilder) Total(input string) *StateExecTimeoutBuilder {
	b.model.Total = input
	return b
}

func (b *StateExecTimeoutBuilder) Build() StateExecTimeout {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewStatesBuilder() *StatesBuilder {
	builder := &StatesBuilder{}
	builder.model = States{}
	return builder
}

type StatesBuilder struct {
	model States
}

func (b *StatesBuilder) Build() States {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewSwitchStateBuilder() *SwitchStateBuilder {
	builder := &SwitchStateBuilder{}
	builder.model = SwitchState{}
	builder.defaultcondition = NewDefaultConditionBuilder()
	builder.eventconditions = []*EventConditionBuilder{}
	builder.dataconditions = []*DataConditionBuilder{}
	return builder
}

type SwitchStateBuilder struct {
	model            SwitchState
	defaultcondition *DefaultConditionBuilder
	eventconditions  []*EventConditionBuilder
	dataconditions   []*DataConditionBuilder
	timeouts         *SwitchStateTimeoutBuilder
}

func (b *SwitchStateBuilder) DefaultCondition() *DefaultConditionBuilder {
	return b.defaultcondition
}

func (b *SwitchStateBuilder) AddEventConditions() *EventConditionBuilder {
	builder := NewEventConditionBuilder()
	b.eventconditions = append(b.eventconditions, builder)
	return builder
}

func (b *SwitchStateBuilder) RemoveEventConditions(remove *EventConditionBuilder) {
	for i, val := range b.eventconditions {
		if val == remove {
			b.eventconditions[i] = b.eventconditions[len(b.eventconditions)-1]
			b.eventconditions = b.eventconditions[:len(b.eventconditions)-1]
		}
	}
}
func (b *SwitchStateBuilder) AddDataConditions() *DataConditionBuilder {
	builder := NewDataConditionBuilder()
	b.dataconditions = append(b.dataconditions, builder)
	return builder
}

func (b *SwitchStateBuilder) RemoveDataConditions(remove *DataConditionBuilder) {
	for i, val := range b.dataconditions {
		if val == remove {
			b.dataconditions[i] = b.dataconditions[len(b.dataconditions)-1]
			b.dataconditions = b.dataconditions[:len(b.dataconditions)-1]
		}
	}
}
func (b *SwitchStateBuilder) Timeouts() *SwitchStateTimeoutBuilder {
	if b.timeouts == nil {
		b.timeouts = NewSwitchStateTimeoutBuilder()
	}
	return b.timeouts
}

func (b *SwitchStateBuilder) Build() SwitchState {
	b.model.DefaultCondition = b.defaultcondition.Build()
	b.model.EventConditions = []EventCondition{}
	for _, v := range b.eventconditions {
		b.model.EventConditions = append(b.model.EventConditions, v.Build())
	}
	b.model.DataConditions = []DataCondition{}
	for _, v := range b.dataconditions {
		b.model.DataConditions = append(b.model.DataConditions, v.Build())
	}
	if b.timeouts != nil {
		timeouts := b.timeouts.Build()
		b.model.Timeouts = &timeouts
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewSwitchStateTimeoutBuilder() *SwitchStateTimeoutBuilder {
	builder := &SwitchStateTimeoutBuilder{}
	builder.model = SwitchStateTimeout{}
	return builder
}

type SwitchStateTimeoutBuilder struct {
	model            SwitchStateTimeout
	stateexectimeout *StateExecTimeoutBuilder
}

func (b *SwitchStateTimeoutBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *SwitchStateTimeoutBuilder) EventTimeout(input string) *SwitchStateTimeoutBuilder {
	b.model.EventTimeout = input
	return b
}

func (b *SwitchStateTimeoutBuilder) Build() SwitchStateTimeout {
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewTimeoutsBuilder() *TimeoutsBuilder {
	builder := &TimeoutsBuilder{}
	builder.model = Timeouts{}
	return builder
}

type TimeoutsBuilder struct {
	model               Timeouts
	workflowexectimeout *WorkflowExecTimeoutBuilder
	stateexectimeout    *StateExecTimeoutBuilder
}

func (b *TimeoutsBuilder) WorkflowExecTimeout() *WorkflowExecTimeoutBuilder {
	if b.workflowexectimeout == nil {
		b.workflowexectimeout = NewWorkflowExecTimeoutBuilder()
	}
	return b.workflowexectimeout
}

func (b *TimeoutsBuilder) StateExecTimeout() *StateExecTimeoutBuilder {
	if b.stateexectimeout == nil {
		b.stateexectimeout = NewStateExecTimeoutBuilder()
	}
	return b.stateexectimeout
}

func (b *TimeoutsBuilder) ActionExecTimeout(input string) *TimeoutsBuilder {
	b.model.ActionExecTimeout = input
	return b
}

func (b *TimeoutsBuilder) BranchExecTimeout(input string) *TimeoutsBuilder {
	b.model.BranchExecTimeout = input
	return b
}

func (b *TimeoutsBuilder) EventTimeout(input string) *TimeoutsBuilder {
	b.model.EventTimeout = input
	return b
}

func (b *TimeoutsBuilder) Build() Timeouts {
	if b.workflowexectimeout != nil {
		workflowexectimeout := b.workflowexectimeout.Build()
		b.model.WorkflowExecTimeout = &workflowexectimeout
	}
	if b.stateexectimeout != nil {
		stateexectimeout := b.stateexectimeout.Build()
		b.model.StateExecTimeout = &stateexectimeout
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewTransitionBuilder() *TransitionBuilder {
	builder := &TransitionBuilder{}
	builder.model = Transition{}
	builder.produceevents = []*ProduceEventBuilder{}
	return builder
}

type TransitionBuilder struct {
	model         Transition
	stateparent   *StateBuilder
	produceevents []*ProduceEventBuilder
}

func (b *TransitionBuilder) stateParent() *StateBuilder {
	if b.stateparent == nil {
		b.stateparent = NewStateBuilder()
	}
	return b.stateparent
}

func (b *TransitionBuilder) NextState(input string) *TransitionBuilder {
	b.model.NextState = input
	return b
}

func (b *TransitionBuilder) AddProduceEvents() *ProduceEventBuilder {
	builder := NewProduceEventBuilder()
	b.produceevents = append(b.produceevents, builder)
	return builder
}

func (b *TransitionBuilder) RemoveProduceEvents(remove *ProduceEventBuilder) {
	for i, val := range b.produceevents {
		if val == remove {
			b.produceevents[i] = b.produceevents[len(b.produceevents)-1]
			b.produceevents = b.produceevents[:len(b.produceevents)-1]
		}
	}
}
func (b *TransitionBuilder) Compensate(input bool) *TransitionBuilder {
	b.model.Compensate = input
	return b
}

func (b *TransitionBuilder) Build() Transition {
	if b.stateparent != nil {
		stateparent := b.stateparent.Build()
		b.model.stateParent = &stateparent
	}
	b.model.ProduceEvents = []ProduceEvent{}
	for _, v := range b.produceevents {
		b.model.ProduceEvents = append(b.model.ProduceEvents, v.Build())
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewWorkflowBuilder() *WorkflowBuilder {
	builder := &WorkflowBuilder{}
	builder.model = Workflow{}
	builder.BaseWorkflowBuilder = *NewBaseWorkflowBuilder()
	builder.states = []*StateBuilder{}
	builder.events = []*EventBuilder{}
	builder.functions = []*FunctionBuilder{}
	builder.retries = []*RetryBuilder{}
	return builder
}

type WorkflowBuilder struct {
	model Workflow
	BaseWorkflowBuilder
	states    []*StateBuilder
	events    []*EventBuilder
	functions []*FunctionBuilder
	retries   []*RetryBuilder
}

func (b *WorkflowBuilder) ID(input string) *WorkflowBuilder {
	b.BaseWorkflowBuilder.ID(input)
	return b
}

func (b *WorkflowBuilder) Key(input string) *WorkflowBuilder {
	b.BaseWorkflowBuilder.Key(input)
	return b
}

func (b *WorkflowBuilder) Name(input string) *WorkflowBuilder {
	b.BaseWorkflowBuilder.Name(input)
	return b
}

func (b *WorkflowBuilder) Description(input string) *WorkflowBuilder {
	b.BaseWorkflowBuilder.Description(input)
	return b
}

func (b *WorkflowBuilder) Version(input string) *WorkflowBuilder {
	b.BaseWorkflowBuilder.Version(input)
	return b
}

func (b *WorkflowBuilder) SpecVersion(input string) *WorkflowBuilder {
	b.BaseWorkflowBuilder.SpecVersion(input)
	return b
}

func (b *WorkflowBuilder) ExpressionLang(input ExpressionLangType) *WorkflowBuilder {
	b.BaseWorkflowBuilder.ExpressionLang(input)
	return b
}

func (b *WorkflowBuilder) KeepActive(input bool) *WorkflowBuilder {
	b.BaseWorkflowBuilder.KeepActive(input)
	return b
}

func (b *WorkflowBuilder) AutoRetries(input bool) *WorkflowBuilder {
	b.BaseWorkflowBuilder.AutoRetries(input)
	return b
}

func (b *WorkflowBuilder) AddStates() *StateBuilder {
	builder := NewStateBuilder()
	b.states = append(b.states, builder)
	return builder
}

func (b *WorkflowBuilder) RemoveStates(remove *StateBuilder) {
	for i, val := range b.states {
		if val == remove {
			b.states[i] = b.states[len(b.states)-1]
			b.states = b.states[:len(b.states)-1]
		}
	}
}
func (b *WorkflowBuilder) AddEvents() *EventBuilder {
	builder := NewEventBuilder()
	b.events = append(b.events, builder)
	return builder
}

func (b *WorkflowBuilder) RemoveEvents(remove *EventBuilder) {
	for i, val := range b.events {
		if val == remove {
			b.events[i] = b.events[len(b.events)-1]
			b.events = b.events[:len(b.events)-1]
		}
	}
}
func (b *WorkflowBuilder) AddFunctions() *FunctionBuilder {
	builder := NewFunctionBuilder()
	b.functions = append(b.functions, builder)
	return builder
}

func (b *WorkflowBuilder) RemoveFunctions(remove *FunctionBuilder) {
	for i, val := range b.functions {
		if val == remove {
			b.functions[i] = b.functions[len(b.functions)-1]
			b.functions = b.functions[:len(b.functions)-1]
		}
	}
}
func (b *WorkflowBuilder) AddRetries() *RetryBuilder {
	builder := NewRetryBuilder()
	b.retries = append(b.retries, builder)
	return builder
}

func (b *WorkflowBuilder) RemoveRetries(remove *RetryBuilder) {
	for i, val := range b.retries {
		if val == remove {
			b.retries[i] = b.retries[len(b.retries)-1]
			b.retries = b.retries[:len(b.retries)-1]
		}
	}
}
func (b *WorkflowBuilder) Build() Workflow {
	b.model.BaseWorkflow = b.BaseWorkflowBuilder.Build()
	b.model.States = []State{}
	for _, v := range b.states {
		b.model.States = append(b.model.States, v.Build())
	}
	b.model.Events = []Event{}
	for _, v := range b.events {
		b.model.Events = append(b.model.Events, v.Build())
	}
	b.model.Functions = []Function{}
	for _, v := range b.functions {
		b.model.Functions = append(b.model.Functions, v.Build())
	}
	b.model.Retries = []Retry{}
	for _, v := range b.retries {
		b.model.Retries = append(b.model.Retries, v.Build())
	}
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewWorkflowExecTimeoutBuilder() *WorkflowExecTimeoutBuilder {
	builder := &WorkflowExecTimeoutBuilder{}
	builder.model = WorkflowExecTimeout{}
	builder.model.ApplyDefault()
	return builder
}

type WorkflowExecTimeoutBuilder struct {
	model WorkflowExecTimeout
}

func (b *WorkflowExecTimeoutBuilder) Duration(input string) *WorkflowExecTimeoutBuilder {
	b.model.Duration = input
	return b
}

func (b *WorkflowExecTimeoutBuilder) Interrupt(input bool) *WorkflowExecTimeoutBuilder {
	b.model.Interrupt = input
	return b
}

func (b *WorkflowExecTimeoutBuilder) RunBefore(input string) *WorkflowExecTimeoutBuilder {
	b.model.RunBefore = input
	return b
}

func (b *WorkflowExecTimeoutBuilder) Build() WorkflowExecTimeout {
	return b.model
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func NewWorkflowRefBuilder() *WorkflowRefBuilder {
	builder := &WorkflowRefBuilder{}
	builder.model = WorkflowRef{}
	builder.model.ApplyDefault()
	return builder
}

type WorkflowRefBuilder struct {
	model WorkflowRef
}

func (b *WorkflowRefBuilder) WorkflowID(input string) *WorkflowRefBuilder {
	b.model.WorkflowID = input
	return b
}

func (b *WorkflowRefBuilder) Version(input string) *WorkflowRefBuilder {
	b.model.Version = input
	return b
}

func (b *WorkflowRefBuilder) Invoke(input InvokeKind) *WorkflowRefBuilder {
	b.model.Invoke = input
	return b
}

func (b *WorkflowRefBuilder) OnParentComplete(input OnParentCompleteType) *WorkflowRefBuilder {
	b.model.OnParentComplete = input
	return b
}

func (b *WorkflowRefBuilder) Build() WorkflowRef {
	return b.model
}
