// Copyright 2020 The Serverless Workflow Specification Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package sw

import (
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Action) DeepCopyInto(out *Action) {
	*out = *in
	if in.ActionDataFilter != nil {
		in, out := &in.ActionDataFilter, &out.ActionDataFilter
		*out = new(Actiondatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.EventRef != nil {
		in, out := &in.EventRef, &out.EventRef
		*out = new(Eventref)
		(*in).DeepCopyInto(*out)
	}
	if in.FunctionRef != nil {
		in, out := &in.FunctionRef, &out.FunctionRef
		*out = new(Functionref)
		(*in).DeepCopyInto(*out)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Action.
func (in *Action) DeepCopy() *Action {
	if in == nil {
		return nil
	}
	out := new(Action)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Actiondatafilter) DeepCopyInto(out *Actiondatafilter) {
	*out = *in
	if in.DataInputPath != nil {
		in, out := &in.DataInputPath, &out.DataInputPath
		*out = new(string)
		**out = **in
	}
	if in.DataResultsPath != nil {
		in, out := &in.DataResultsPath, &out.DataResultsPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Actiondatafilter.
func (in *Actiondatafilter) DeepCopy() *Actiondatafilter {
	if in == nil {
		return nil
	}
	out := new(Actiondatafilter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Branch) DeepCopyInto(out *Branch) {
	*out = *in
	if in.Actions != nil {
		in, out := &in.Actions, &out.Actions
		*out = make([]Action, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.States != nil {
		in, out := &in.States, &out.States
		*out = make([]runtime.RawExtension, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Branch.
func (in *Branch) DeepCopy() *Branch {
	if in == nil {
		return nil
	}
	out := new(Branch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Callbackstate) DeepCopyInto(out *Callbackstate) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(Action)
		(*in).DeepCopyInto(*out)
	}
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.EventDataFilter != nil {
		in, out := &in.EventDataFilter, &out.EventDataFilter
		*out = new(Eventdatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.EventRef != nil {
		in, out := &in.EventRef, &out.EventRef
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = make([]Retry, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(string)
		**out = **in
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(CallbackstateType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Callbackstate.
func (in *Callbackstate) DeepCopy() *Callbackstate {
	if in == nil {
		return nil
	}
	out := new(Callbackstate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CorrelationDef) DeepCopyInto(out *CorrelationDef) {
	*out = *in
	if in.ContextAttributeValue != nil {
		in, out := &in.ContextAttributeValue, &out.ContextAttributeValue
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CorrelationDef.
func (in *CorrelationDef) DeepCopy() *CorrelationDef {
	if in == nil {
		return nil
	}
	out := new(CorrelationDef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Databasedswitch) DeepCopyInto(out *Databasedswitch) {
	*out = *in
	if in.DataConditions != nil {
		in, out := &in.DataConditions, &out.DataConditions
		*out = make([]Datacondition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.Default != nil {
		in, out := &in.Default, &out.Default
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(DatabasedswitchType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Databasedswitch.
func (in *Databasedswitch) DeepCopy() *Databasedswitch {
	if in == nil {
		return nil
	}
	out := new(Databasedswitch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Datacondition) DeepCopyInto(out *Datacondition) {
	*out = *in
	in.Transition.DeepCopyInto(&out.Transition)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Datacondition.
func (in *Datacondition) DeepCopy() *Datacondition {
	if in == nil {
		return nil
	}
	out := new(Datacondition)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Delaystate) DeepCopyInto(out *Delaystate) {
	*out = *in
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.TimeDelay != nil {
		in, out := &in.TimeDelay, &out.TimeDelay
		*out = new(string)
		**out = **in
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(DelaystateType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Delaystate.
func (in *Delaystate) DeepCopy() *Delaystate {
	if in == nil {
		return nil
	}
	out := new(Delaystate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *End) DeepCopyInto(out *End) {
	*out = *in
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(EndKind)
		**out = **in
	}
	if in.ProduceEvent != nil {
		in, out := &in.ProduceEvent, &out.ProduceEvent
		*out = new(Produceevent)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new End.
func (in *End) DeepCopy() *End {
	if in == nil {
		return nil
	}
	out := new(End)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Error) DeepCopyInto(out *Error) {
	*out = *in
	if in.ErrorDataFilter != nil {
		in, out := &in.ErrorDataFilter, &out.ErrorDataFilter
		*out = new(Errordatafilter)
		(*in).DeepCopyInto(*out)
	}
	in.Transition.DeepCopyInto(&out.Transition)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Error.
func (in *Error) DeepCopy() *Error {
	if in == nil {
		return nil
	}
	out := new(Error)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Errordatafilter) DeepCopyInto(out *Errordatafilter) {
	*out = *in
	if in.DataOutputPath != nil {
		in, out := &in.DataOutputPath, &out.DataOutputPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Errordatafilter.
func (in *Errordatafilter) DeepCopy() *Errordatafilter {
	if in == nil {
		return nil
	}
	out := new(Errordatafilter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Eventactions) DeepCopyInto(out *Eventactions) {
	*out = *in
	if in.Actions != nil {
		in, out := &in.Actions, &out.Actions
		*out = make([]Action, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EventDataFilter != nil {
		in, out := &in.EventDataFilter, &out.EventDataFilter
		*out = new(Eventdatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.EventRefs != nil {
		in, out := &in.EventRefs, &out.EventRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Eventactions.
func (in *Eventactions) DeepCopy() *Eventactions {
	if in == nil {
		return nil
	}
	out := new(Eventactions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Eventbasedswitch) DeepCopyInto(out *Eventbasedswitch) {
	*out = *in
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.Default != nil {
		in, out := &in.Default, &out.Default
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.EventConditions != nil {
		in, out := &in.EventConditions, &out.EventConditions
		*out = make([]Eventcondition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EventTimeout != nil {
		in, out := &in.EventTimeout, &out.EventTimeout
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(EventbasedswitchType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Eventbasedswitch.
func (in *Eventbasedswitch) DeepCopy() *Eventbasedswitch {
	if in == nil {
		return nil
	}
	out := new(Eventbasedswitch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Eventcondition) DeepCopyInto(out *Eventcondition) {
	*out = *in
	in.Transition.DeepCopyInto(&out.Transition)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Eventcondition.
func (in *Eventcondition) DeepCopy() *Eventcondition {
	if in == nil {
		return nil
	}
	out := new(Eventcondition)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Eventdatafilter) DeepCopyInto(out *Eventdatafilter) {
	*out = *in
	if in.DataOutputPath != nil {
		in, out := &in.DataOutputPath, &out.DataOutputPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Eventdatafilter.
func (in *Eventdatafilter) DeepCopy() *Eventdatafilter {
	if in == nil {
		return nil
	}
	out := new(Eventdatafilter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Eventdef) DeepCopyInto(out *Eventdef) {
	*out = *in
	if in.Correlation != nil {
		in, out := &in.Correlation, &out.Correlation
		*out = make([]CorrelationDef, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Source != nil {
		in, out := &in.Source, &out.Source
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Eventdef.
func (in *Eventdef) DeepCopy() *Eventdef {
	if in == nil {
		return nil
	}
	out := new(Eventdef)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Eventref) DeepCopyInto(out *Eventref) {
	*out = *in
	in.ContextAttributes.DeepCopyInto(&out.ContextAttributes)
	in.Data.DeepCopyInto(&out.Data)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Eventref.
func (in *Eventref) DeepCopy() *Eventref {
	if in == nil {
		return nil
	}
	out := new(Eventref)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Events) DeepCopyInto(out *Events) {
	{
		in := &in
		*out = make(Events, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Events.
func (in Events) DeepCopy() Events {
	if in == nil {
		return nil
	}
	out := new(Events)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Eventstate) DeepCopyInto(out *Eventstate) {
	*out = *in
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.EventsActions != nil {
		in, out := &in.EventsActions, &out.EventsActions
		*out = make([]Eventactions, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = make([]Retry, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(string)
		**out = **in
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(EventstateType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Eventstate.
func (in *Eventstate) DeepCopy() *Eventstate {
	if in == nil {
		return nil
	}
	out := new(Eventstate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Foreachstate) DeepCopyInto(out *Foreachstate) {
	*out = *in
	if in.Actions != nil {
		in, out := &in.Actions, &out.Actions
		*out = make([]Action, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.InputCollection != nil {
		in, out := &in.InputCollection, &out.InputCollection
		*out = new(string)
		**out = **in
	}
	if in.InputParameter != nil {
		in, out := &in.InputParameter, &out.InputParameter
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OutputCollection != nil {
		in, out := &in.OutputCollection, &out.OutputCollection
		*out = new(string)
		**out = **in
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = make([]Retry, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.States != nil {
		in, out := &in.States, &out.States
		*out = make([]runtime.RawExtension, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TimeDelay != nil {
		in, out := &in.TimeDelay, &out.TimeDelay
		*out = new(string)
		**out = **in
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(ForeachstateType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Foreachstate.
func (in *Foreachstate) DeepCopy() *Foreachstate {
	if in == nil {
		return nil
	}
	out := new(Foreachstate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Function) DeepCopyInto(out *Function) {
	*out = *in
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Function.
func (in *Function) DeepCopy() *Function {
	if in == nil {
		return nil
	}
	out := new(Function)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Functionref) DeepCopyInto(out *Functionref) {
	*out = *in
	in.Parameters.DeepCopyInto(&out.Parameters)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Functionref.
func (in *Functionref) DeepCopy() *Functionref {
	if in == nil {
		return nil
	}
	out := new(Functionref)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Functions) DeepCopyInto(out *Functions) {
	{
		in := &in
		*out = make(Functions, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Functions.
func (in Functions) DeepCopy() Functions {
	if in == nil {
		return nil
	}
	out := new(Functions)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Injectstate) DeepCopyInto(out *Injectstate) {
	*out = *in
	in.Data.DeepCopyInto(&out.Data)
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(InjectstateType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Injectstate.
func (in *Injectstate) DeepCopy() *Injectstate {
	if in == nil {
		return nil
	}
	out := new(Injectstate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Metadata) DeepCopyInto(out *Metadata) {
	{
		in := &in
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Metadata.
func (in Metadata) DeepCopy() Metadata {
	if in == nil {
		return nil
	}
	out := new(Metadata)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Operationstate) DeepCopyInto(out *Operationstate) {
	*out = *in
	if in.Actions != nil {
		in, out := &in.Actions, &out.Actions
		*out = make([]Action, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = make([]Retry, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(OperationstateType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Operationstate.
func (in *Operationstate) DeepCopy() *Operationstate {
	if in == nil {
		return nil
	}
	out := new(Operationstate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Parallelstate) DeepCopyInto(out *Parallelstate) {
	*out = *in
	if in.Branches != nil {
		in, out := &in.Branches, &out.Branches
		*out = make([]Branch, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = make([]Retry, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(ParallelstateType)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Parallelstate.
func (in *Parallelstate) DeepCopy() *Parallelstate {
	if in == nil {
		return nil
	}
	out := new(Parallelstate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Produceevent) DeepCopyInto(out *Produceevent) {
	*out = *in
	in.ContextAttributes.DeepCopyInto(&out.ContextAttributes)
	in.Data.DeepCopyInto(&out.Data)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Produceevent.
func (in *Produceevent) DeepCopy() *Produceevent {
	if in == nil {
		return nil
	}
	out := new(Produceevent)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Retry) DeepCopyInto(out *Retry) {
	*out = *in
	if in.Interval != nil {
		in, out := &in.Interval, &out.Interval
		*out = new(string)
		**out = **in
	}
	if in.Multiplier != nil {
		in, out := &in.Multiplier, &out.Multiplier
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Retry.
func (in *Retry) DeepCopy() *Retry {
	if in == nil {
		return nil
	}
	out := new(Retry)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Schedule) DeepCopyInto(out *Schedule) {
	*out = *in
	if in.Cron != nil {
		in, out := &in.Cron, &out.Cron
		*out = new(string)
		**out = **in
	}
	if in.DirectInvoke != nil {
		in, out := &in.DirectInvoke, &out.DirectInvoke
		*out = new(ScheduleDirectInvoke)
		**out = **in
	}
	if in.Interval != nil {
		in, out := &in.Interval, &out.Interval
		*out = new(string)
		**out = **in
	}
	if in.Timezone != nil {
		in, out := &in.Timezone, &out.Timezone
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Schedule.
func (in *Schedule) DeepCopy() *Schedule {
	if in == nil {
		return nil
	}
	out := new(Schedule)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Start) DeepCopyInto(out *Start) {
	*out = *in
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(StartKind)
		**out = **in
	}
	if in.Schedule != nil {
		in, out := &in.Schedule, &out.Schedule
		*out = new(Schedule)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Start.
func (in *Start) DeepCopy() *Start {
	if in == nil {
		return nil
	}
	out := new(Start)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Statedatafilter) DeepCopyInto(out *Statedatafilter) {
	*out = *in
	if in.DataInputPath != nil {
		in, out := &in.DataInputPath, &out.DataInputPath
		*out = new(string)
		**out = **in
	}
	if in.DataOutputPath != nil {
		in, out := &in.DataOutputPath, &out.DataOutputPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Statedatafilter.
func (in *Statedatafilter) DeepCopy() *Statedatafilter {
	if in == nil {
		return nil
	}
	out := new(Statedatafilter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Subflowstate) DeepCopyInto(out *Subflowstate) {
	*out = *in
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.End != nil {
		in, out := &in.End, &out.End
		*out = new(End)
		(*in).DeepCopyInto(*out)
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OnError != nil {
		in, out := &in.OnError, &out.OnError
		*out = make([]Error, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Start != nil {
		in, out := &in.Start, &out.Start
		*out = new(Start)
		(*in).DeepCopyInto(*out)
	}
	if in.StateDataFilter != nil {
		in, out := &in.StateDataFilter, &out.StateDataFilter
		*out = new(Statedatafilter)
		(*in).DeepCopyInto(*out)
	}
	if in.Transition != nil {
		in, out := &in.Transition, &out.Transition
		*out = new(Transition)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(SubflowstateType)
		**out = **in
	}
	if in.WorkflowId != nil {
		in, out := &in.WorkflowId, &out.WorkflowId
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Subflowstate.
func (in *Subflowstate) DeepCopy() *Subflowstate {
	if in == nil {
		return nil
	}
	out := new(Subflowstate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Transition) DeepCopyInto(out *Transition) {
	*out = *in
	if in.Expression != nil {
		in, out := &in.Expression, &out.Expression
		*out = new(string)
		**out = **in
	}
	if in.ProduceEvent != nil {
		in, out := &in.ProduceEvent, &out.ProduceEvent
		*out = new(Produceevent)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Transition.
func (in *Transition) DeepCopy() *Transition {
	if in == nil {
		return nil
	}
	out := new(Transition)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Workflow) DeepCopyInto(out *Workflow) {
	*out = *in
	if in.DataInputSchema != nil {
		in, out := &in.DataInputSchema, &out.DataInputSchema
		*out = new(string)
		**out = **in
	}
	if in.DataOutputSchema != nil {
		in, out := &in.DataOutputSchema, &out.DataOutputSchema
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Events != nil {
		in, out := &in.Events, &out.Events
		*out = make(Events, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Extensions != nil {
		in, out := &in.Extensions, &out.Extensions
		*out = make([]runtime.RawExtension, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Functions != nil {
		in, out := &in.Functions, &out.Functions
		*out = make(Functions, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(Metadata, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SchemaVersion != nil {
		in, out := &in.SchemaVersion, &out.SchemaVersion
		*out = new(string)
		**out = **in
	}
	if in.States != nil {
		in, out := &in.States, &out.States
		*out = make([]runtime.RawExtension, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Workflow.
func (in *Workflow) DeepCopy() *Workflow {
	if in == nil {
		return nil
	}
	out := new(Workflow)
	in.DeepCopyInto(out)
	return out
}
